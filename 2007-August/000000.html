<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Hmgen-svnlog] r1 - / trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/hmgen-svnlog/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:hmgen-svnlog%40lists.berlios.de?Subject=Re%3A%20%5BHmgen-svnlog%5D%20r1%20-%20/%20trunk&In-Reply-To=%3C200708281038.l7SAcow2021246%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000001.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Hmgen-svnlog] r1 - / trunk</H1>
    <B>ivop at BerliOS</B> 
    <A HREF="mailto:hmgen-svnlog%40lists.berlios.de?Subject=Re%3A%20%5BHmgen-svnlog%5D%20r1%20-%20/%20trunk&In-Reply-To=%3C200708281038.l7SAcow2021246%40sheep.berlios.de%3E"
       TITLE="[Hmgen-svnlog] r1 - / trunk">ivop at mail.berlios.de
       </A><BR>
    <I>Tue Aug 28 12:38:50 CEST 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000001.html">[Hmgen-svnlog] r2 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ivop
Date: 2007-08-28 12:38:44 +0200 (Tue, 28 Aug 2007)
New Revision: 1

Added:
   trunk/
   trunk/AUTHORS
   trunk/LICENSE
   trunk/Makefile
   trunk/README
   trunk/cli_main.c
   trunk/gui_callbacks.c
   trunk/gui_callbacks.h
   trunk/gui_interface.c
   trunk/gui_interface.h
   trunk/gui_main.c
   trunk/gui_support.c
   trunk/gui_support.h
   trunk/hmgen.png
   trunk/lib_algo_ff.c
   trunk/lib_algo_forge.c
   trunk/lib_algo_mpd.c
   trunk/lib_hmgen.c
   trunk/lib_hmgen.h
   trunk/lib_postproc.c
   trunk/lib_util.c
   trunk/target.mak
   trunk/version.h
Log:
Initial Import

Added: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/AUTHORS	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1 @@
+Ivo van Poorten &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/hmgen-svnlog">ivop at euronet.nl</A>&gt;

Added: trunk/LICENSE
===================================================================
--- trunk/LICENSE	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/LICENSE	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+        51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/Makefile
===================================================================
--- trunk/Makefile	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/Makefile	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,88 @@
+
+include target.mak
+
+CLI = hmgen$(EXESUF)
+CLIg = hmgen_g$(EXESUF)
+CLI_BASENAMES = cli_main
+CLI_OBJS = $(addsuffix $(OBJSUF), $(CLI_BASENAMES))
+CLI_SRCS = $(addsuffix .c, $(CLI_BASENAMES))
+
+GUI = hmgengui$(EXESUF)
+GUIg = hmgengui_g$(EXESUF)
+GUI_BASENAMES = gui_main gui_callbacks gui_interface gui_support
+GUI_OBJS = $(addsuffix $(OBJSUF), $(GUI_BASENAMES))
+GUI_SRCS = $(addsuffix .c, $(GUI_BASENAMES))
+
+LIBHMGEN = libhmgen.a
+LIBHMGEN_BASENAMES = lib_algo_ff lib_algo_mpd lib_algo_forge \
+					 lib_postproc lib_util lib_hmgen
+LIBHMGEN_OBJS = $(addsuffix $(OBJSUF), $(LIBHMGEN_BASENAMES))
+LIBHMGEN_SRCS = $(addsuffix .c, $(LIBHMGEN_BASENAMES))
+
+SILENT ?= yes
+SILENT_EXEC = test &quot;$(SILENT)&quot; = &quot;yes&quot; &amp;&amp; echo $$SHORT || echo $$LONG; $$LONG
+
+all: $(GUI) $(CLI)
+
+verbose: SILENT=no
+verbose: all
+
+$(CLI)-verbose: SILENT=no
+$(CLI)-verbose: $(CLI)
+$(CLI): $(CLIg)
+	@LONG=&quot;cp $(CLIg) $@&quot;; SHORT=&quot;CP $(CLIg) $@&quot;; $(SILENT_EXEC)
+	@LONG=&quot;$(STRIP) $@&quot;; SHORT=&quot;STRIP $@&quot;; $(SILENT_EXEC)
+
+$(CLIg): CFLAGS = $(DEF_CFLAGS)
+$(CLIg): LDFLAGS = $(DEF_LDFLAGS)
+$(CLIg): $(LIBHMGEN) $(CLI_OBJS)
+	@LONG=&quot;$(CC) -o $@ $(CLI_OBJS) $(LIBHMGEN) $(LDFLAGS)&quot;; SHORT=&quot;LD $@&quot;; \
+		$(SILENT_EXEC)
+
+$(GUI)-verbose: SILENT=no
+$(GUI)-verbose: $(GUI)
+$(GUI): $(GUIg)
+	@LONG=&quot;cp $(GUIg) $@&quot;; SHORT=&quot;CP $(GUIg) $@&quot;; $(SILENT_EXEC)
+	@LONG=&quot;$(STRIP) $@&quot;; SHORT=&quot;STRIP $@&quot;; $(SILENT_EXEC)
+
+$(GUIg): CFLAGS = $(GTK_CFLAGS) $(DEF_CFLAGS)
+$(GUIg): LDFLAGS = $(GTK_LDFLAGS) $(DEF_LDFLAGS)
+$(GUIg): $(LIBHMGEN) $(GUI_OBJS)
+	@LONG=&quot;$(CC) -o $@ $(GUI_OBJS) $(LIBHMGEN) $(LDFLAGS)&quot;; SHORT=&quot;LD $@&quot;; \
+		$(SILENT_EXEC)
+
+$(LIBHMGEN)-verbose: SILENT=no
+$(LIBHMGEN)-verbose: $(LIBHMGEN)
+$(LIBHMGEN): CFLAGS = $(DEF_CFLAGS)
+$(LIBHMGEN): LDFLAGS = $(DEF_LDFLAGS)
+$(LIBHMGEN): $(LIBHMGEN_OBJS)
+	@LONG=&quot;$(AR) $(AR_FLAGS) $@ $^&quot;; SHORT=&quot;AR $@&quot;; $(SILENT_EXEC)
+	@LONG=&quot;$(RANLIB) $@&quot;; SHORT=&quot;RANLIB $@&quot;; $(SILENT_EXEC)
+
+.c.o:
+	@LONG=&quot;$(CC) -c -o $@ $&lt; $(CFLAGS)&quot;; SHORT=&quot;CC $&lt;&quot;; $(SILENT_EXEC)
+
+clean:
+	rm -f $(CLI) $(CLIg) $(CLI_OBJS)
+	rm -f $(LIBHMGEN) $(LIBHMGEN_OBJS)
+	rm -f $(GUI) $(GUIg) $(GUI_OBJS)
+
+mrproper distclean: clean
+	rm -f *~ .depend *.pgm *.ppm
+
+depend-verbose dep-verbose: SILENT=no
+depend-verbose dep-verbose: dep
+depend dep: $(CLI_SRCS) $(LIBHMGEN_SRCS) $(GUI_SRCS)
+	@LONG=&quot;$(CC_DEP) $(DEP_FLAGS) $(DEF_CFLAGS) $(GTK_CFLAGS) $^&quot;; \
+		SHORT=&quot;CCDEP &gt;.depend&quot;; $(SILENT_EXEC) 1&gt;.depend
+
+size:
+	@wc -l *.[ch] Makefile *.mak | tail -1
+
+size-long:
+	@wc -l *.[ch] Makefile *.mak
+
+.PHONY:	all dep depend clean distclean mrproper verbose $(CLI)-verbose size
+.PHONY: $(GUI)-verbose $(LIBHMGEN)-verbose depend-verbose dep-verbose size-long
+
+-include .depend

Added: trunk/README
===================================================================
--- trunk/README	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/README	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,42 @@
+Requirements:
+=============
+
+Mandatory:
+
+C compiler
+
+Optional:
+
+pkg-config
+gtk+-2.0 + gdk-pixbuf + development files
+
+
+Building:
+=========
+
+One-time build:
+    make all
+
+To build without the GTK+-2.0 GUI, type:
+    make hmgen
+
+Developer build:
+    make dep verbose
+    or
+    make dep hmgen-verbose
+    etc...
+
+Clean up:
+    make clean
+
+Cleaner up:
+    make distclean
+    make mrproper
+
+The default target is linux-gcc. To change that, use:
+    make TARGET=linux-suncc all
+
+Porting to another target can be done by adding it to target.mak.
+
+Yeah, I am too lazy to copy &amp; paste &amp; adjust a proper configure script.
+Send a patch if you want. I will not accept any autotools stuff though.

Added: trunk/cli_main.c
===================================================================
--- trunk/cli_main.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/cli_main.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,258 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;assert.h&gt;
+#include &quot;lib_hmgen.h&quot;
+#include &quot;version.h&quot;
+
+#define DEF_BLURX       31
+#define DEF_BLURY       31
+#define DEF_BLURSIGMA   6.0f
+
+#define DEF_NORMMIN     0
+#define DEF_NORMMAX     255
+
+static const char defoutfile[] = &quot;output.pgm&quot;;
+static const char defcolfile[] = &quot;output.ppm&quot;;
+
+static int size = 8, algo = 0, blur = 0, blurx = DEF_BLURX, blury = DEF_BLURY;
+static double blursigma = DEF_BLURSIGMA;
+static int normmin = DEF_NORMMIN, normmax = DEF_NORMMAX,
+           normfirst = 0, normlast = 0, inv = 0;
+static unsigned int w, h;
+static char *outfile = (char *) defoutfile;
+static char *colfile = (char *) defcolfile;
+static unsigned int outputcol = 0;
+static const char *params = NULL;
+
+static unsigned char *map, *tempmap;
+
+static void help_message(char **argv) {
+    fprintf(stderr,
+&quot;\nHeight Map Generator - Version %s - %s\n\n&quot;
+&quot;usage: %s [options]\n\n&quot;
+&quot;-s INT         size, 2^VAL+1 [default: 8]\n&quot;
+&quot;-o FILE        output filename [default: output.pgm]\n&quot;
+&quot;-c             enable output of colorized version\n&quot;
+&quot;-cfile FILE    output file name of colorized version [default: output.ppm]\n&quot;
+&quot;-p STRING      algorithm parameters (param:param:param...)\n&quot;
+&quot;-a INT         algorithm [default: 0]\n&quot;
+&quot;                   0 - Fault Formation\n&quot;
+&quot;                       seed=INT        random seed\n&quot;
+&quot;                       init=INT        initial height (0-255)\n&quot;
+&quot;                       n=INT           number of tectonic plates\n&quot;
+&quot;                       up=INT          move up factor\n&quot;
+&quot;                       down=INT        move down factor\n&quot;
+&quot;                   1 - Midpoint Displacement (plasma)\n&quot;
+&quot;                       seed=INT        random seed\n&quot;
+&quot;                       tl=INT          top-left initial height\n&quot;
+&quot;                       tr=INT          top-right initial height\n&quot;
+&quot;                       bl=INT          bottom-left initial height\n&quot;
+&quot;                       br=INT          bottom-right initial height\n&quot;
+&quot;                       d=INT           initial displacement\n&quot;
+&quot;                       r=FLOAT         roughness factor\n&quot;
+&quot;                   2 - ppmforge/gforge Algorithm\n&quot;
+&quot;                       seed=INT        random seed\n&quot;
+&quot;                       fracdim=FLOAT   fractal dimension\n&quot;
+&quot;                       powscale=FLOAT  power scale\n&quot;
+&quot;\n&quot;
+&quot;-nf            postprocess, normalize first [default: no]\n&quot;
+&quot;-nl            postprocess, normalize last [default: no]\n&quot;
+&quot;-nmin INT      normalize minimum (0-255) [default: %i]\n&quot;
+&quot;-nmax INT      normalize maximum (0-255) [default: %i]\n&quot;
+&quot;-b             postprocess, gaussian blur [default: no]\n&quot;
+&quot;-bx INT        blur x-radius [default: %i]\n&quot;
+&quot;-by INT        blur y-radius [default: %i]\n&quot;
+&quot;-bxy INT       blur xy-radius\n&quot;
+&quot;-bs FLOAT      blur sigma [default: %0.2f]\n&quot;
+&quot;-i             postprocess, invert heightmap [default: no]\n&quot;
+&quot;\n&quot;,
+        VERSION_STRING, COPYRIGHT_STRING, argv[0],
+        DEF_NORMMIN, DEF_NORMMAX,
+        DEF_BLURX, DEF_BLURY, DEF_BLURSIGMA);
+    exit(0);
+}
+
+static inline int test_argument(int a, int argc, char **argv) {
+    if (a+1 &gt;= argc) {
+        fprintf(stderr, &quot;option %s needs an argument\n&quot;, argv[a]);
+        return 0;
+    } else
+        return 1;
+}
+
+static int parse_command_line(int argc, char**argv) {
+    int a;
+
+    a = 1;
+
+    while (a &lt; argc) {
+        if (!strcmp(argv[a], &quot;-s&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            size = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-a&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            algo = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-o&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            outfile = argv[++a];
+        } else if (!strcmp(argv[a], &quot;-c&quot;)) {
+            outputcol = 1;
+        } else if (!strcmp(argv[a], &quot;-cfile&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            colfile = argv[++a];
+        } else if (!strcmp(argv[a], &quot;-p&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            params = argv[++a];
+        } else if (!strcmp(argv[a], &quot;-b&quot;)) {
+            blur = 1;
+        } else if (!strcmp(argv[a], &quot;-bx&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            blurx = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-by&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            blury = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-bxy&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            blurx = blury = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-bs&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            blursigma = atof(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-h&quot;)) {
+            help_message(argv);
+        } else if (!strcmp(argv[a], &quot;-nf&quot;)) {
+            normfirst = 1;
+        } else if (!strcmp(argv[a], &quot;-nl&quot;)) {
+            normlast = 1;
+        } else if (!strcmp(argv[a], &quot;-nmin&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            normmin = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-nmax&quot;)) {
+            if (!test_argument(a, argc, argv)) return 0;
+            normmax = atoi(argv[++a]);
+        } else if (!strcmp(argv[a], &quot;-i&quot;)) {
+            inv = 1;
+        } else {
+            fprintf(stderr, &quot;unknown option: %s\n&quot;, argv[a]);
+            return 0;
+        }
+        a++;
+    }
+
+    return 1;
+}
+
+static int test_global_settings(void) {
+    if (size&lt;1 || size&gt;14) {
+        fprintf(stderr, &quot;size is smaller than 1 or larger than 16\n&quot;);
+        return 0;
+    }
+    if (algo&lt;ALGO_FF || algo&gt;=ALGO_LAST) {
+        fprintf(stderr, &quot;algo is smaller then %i or larger than %i\n&quot;,
+                ALGO_FF, ALGO_LAST-1);
+        return 0;
+    }
+    if (blurx &lt; 1) {
+        fprintf(stderr, &quot;blurx is smaller than 1\n&quot;);
+        return 0;
+    }
+    if (blury &lt; 1) {
+        fprintf(stderr, &quot;blury is smaller than 1\n&quot;);
+        return 0;
+    }
+    if (normmin &lt; 0) {
+        fprintf(stderr, &quot;normmin is smaller than 0\n&quot;);
+        return 0;
+    }
+    if (normmax &gt; 255) {
+        fprintf(stderr, &quot;normmax is larger than 255\n&quot;);
+        return 0;
+    }
+
+    return 1;
+}
+
+int main(int argc, char **argv) {
+    FILE *fp1, *fp2;
+
+    if (!parse_command_line(argc, argv)) {
+        fprintf(stderr, &quot;error, parsing command line\n&quot;);
+        exit(1);
+    }
+    if (!test_global_settings()) {
+        fprintf(stderr, &quot;error, invalid global settings\n&quot;);
+        exit(1);
+    }
+
+    fp1 = fopen(outfile, &quot;wb&quot;);
+    if (!fp1) {
+        fprintf(stderr, &quot;error, cannot open %s for writing\n&quot;, outfile);
+        exit(1);
+    }
+
+    if (outputcol) {
+        fp2 = fopen(colfile, &quot;wb&quot;);
+        if (!fp2) {
+            fprintf(stderr, &quot;error, cannot open %s for writing\n&quot;, colfile);
+            fclose(fp1);
+            exit(1);
+        }
+    }
+
+    w = h = exp2(size) + 1;
+
+    fprintf(stderr, &quot;Dimensions: %i x %i\n&quot;, w, h);
+    fprintf(stderr, &quot;Algorithm: %s\n&quot;, hmg_algorithms[algo]-&gt;name);
+
+    if (!hmg_parse_params(params, hmg_algorithms[algo]-&gt;params)) {
+        fprintf(stderr, &quot;error, parsing parameters\n&quot;);
+        exit(1);
+    }
+
+    map = calloc(h, w);
+    if (!map) {
+        fprintf(stderr, &quot;error, unable to allocate memory\n&quot;);
+        exit(1);
+    }
+    tempmap = calloc(h, w);
+    if (!tempmap) {
+        fprintf(stderr, &quot;error, unable to allocate memory\n&quot;);
+        free(map);
+        exit(1);
+    }
+
+    hmg_algorithms[algo]-&gt;func(map, tempmap, w, h);
+
+    if (normfirst)
+        hmg_normalize(map, normmin, normmax, w, h);
+    if (blur)
+        hmg_gaussian_blur(map, tempmap, blurx, blury, blursigma, w, h);
+    if (normlast)
+        hmg_normalize(map, normmin, normmax, w, h);
+    if (inv)
+        hmg_invert(map, w, h);
+
+    fprintf(stderr, &quot;Saving to %s\n&quot;, outfile);
+
+    fprintf(fp1, &quot;P5\n# Generated by HMGEN\n%i %i\n255\n&quot;, w, h);
+    fwrite(map, w, h, fp1);
+    fclose(fp1);
+
+    if (outputcol) {
+        unsigned int i;
+        fprintf(stderr, &quot;Saving colorized version to %s\n&quot;, colfile);
+
+        fprintf(fp2, &quot;P6\n# Generated by HMGEN\n%i %i\n255\n&quot;, w, h);
+
+        hmg_init_colormap();
+        for (i=0; i&lt;w*h; i++)
+            fwrite(hmg_colormap[map[i]], 1, 3, fp2);
+
+        fclose(fp2);
+    }
+
+    free(tempmap);
+    free(map);
+    return 0;
+}

Added: trunk/gui_callbacks.c
===================================================================
--- trunk/gui_callbacks.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_callbacks.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,362 @@
+#include &lt;gtk/gtk.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;glib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+#include &quot;gui_callbacks.h&quot;
+#include &quot;gui_interface.h&quot;
+#include &quot;gui_support.h&quot;
+#include &quot;lib_hmgen.h&quot;
+
+static unsigned char *map = NULL, *tempmap = NULL;
+static GdkPixbuf *map_pixbuf = NULL;
+static unsigned int map_width = 4097, map_height = 4097;
+static GtkProgressBar *main_progressbar = NULL;
+static unsigned int algo_combo_set = 0, size_combo_set = 0;
+
+static void gui_progress_meter(char *context, int p) {
+    static char *prevcontext = NULL;
+    static int prevp = 0;
+
+    if (p&gt;=0) {
+        gdk_threads_enter();
+            if (context != prevcontext) {
+                gtk_progress_bar_set_text(main_progressbar, context);
+                prevcontext = context;
+            }
+            if (p&gt;prevp) {
+                gtk_progress_bar_set_fraction(main_progressbar, p/100.0);
+                prevp = p;
+            }
+        gdk_threads_leave();
+    } else {
+        gdk_threads_enter();
+            gtk_progress_bar_set_text(main_progressbar, &quot;Idle...&quot;);
+            gtk_progress_bar_set_fraction(main_progressbar, 0.0);
+            prevp = 0;
+            prevcontext = NULL;
+        gdk_threads_leave();
+    }
+}
+
+static void render_map(GtkWidget *widget) {
+    unsigned int x, y, stride;
+    unsigned char *p, *m;
+
+    if (map_pixbuf) {
+        gdk_threads_enter();
+            g_object_unref(map_pixbuf);
+        gdk_threads_leave();
+    }
+
+    gdk_threads_enter();
+        map_pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, FALSE, 8, map_width, map_height);
+        stride = gdk_pixbuf_get_rowstride(map_pixbuf);
+        p = gdk_pixbuf_get_pixels(map_pixbuf);
+    gdk_threads_leave();
+
+    m = map;
+
+    for (y=0; y&lt;map_height; y++) {
+        if (y&amp;0x10)
+            gui_progress_meter(&quot;Rendering&quot;, round(y*100.0/(map_height-1)));
+        for (x=0; x&lt;map_width; x++) {
+            int x3 = x + (x&lt;&lt;1);
+            p[x3  ] = hmg_colormap[m[x]][0];
+            p[x3+1] = hmg_colormap[m[x]][1];
+            p[x3+2] = hmg_colormap[m[x]][2];
+        }
+        m += map_width;
+        p += stride;
+    }
+    gui_progress_meter(&quot;&quot;, -1);
+}
+
+static void generate_button_sensitivity(GtkComboBox *cb) {
+    GtkWidget *w;
+
+    if (algo_combo_set &amp;&amp; size_combo_set) {
+        w = lookup_widget(GTK_WIDGET(cb), &quot;generate_button&quot;);
+        gtk_widget_set_sensitive (w, TRUE);
+    }
+}
+
+void on_algorithm_combobox_changed(GtkComboBox *combobox, gpointer user_data) {
+    gint active;
+    GtkWidget *w;
+
+    algo_combo_set = 1;
+    generate_button_sensitivity(combobox);
+
+    w = lookup_widget(GTK_WIDGET(combobox), &quot;algosettings_notebook&quot;);
+    active = gtk_combo_box_get_active(combobox);
+
+    gtk_notebook_set_current_page(GTK_NOTEBOOK(w), active);
+}
+
+void on_size_combobox_changed(GtkComboBox *combobox, gpointer user_data) {
+    size_combo_set = 1;
+    generate_button_sensitivity(combobox);
+}
+
+static void retrieve_settings_ff(GtkWidget *widget, char *buf, int len) {
+    GtkWidget *w;
+    unsigned int seed, init, nplates, up, down;
+
+    gdk_threads_enter();
+        w = lookup_widget(widget, &quot;ff_seed_spinbutton&quot;);
+        seed = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;ff_init_spinbutton&quot;);
+        init = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;ff_nplates_spinbutton&quot;);
+        nplates = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;ff_upfactor_spinbutton&quot;);
+        up = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;ff_downfactor_spinbutton&quot;);
+        down = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+    gdk_threads_leave();
+
+    snprintf(buf, len, &quot;seed=%u:init=%u:n=%u:up=%u:down=%u&quot;, seed, init,
+                                                        nplates, up, down);
+}
+
+static void retrieve_settings_mpd(GtkWidget *widget, char *buf, int len) {
+    GtkWidget *w;
+    unsigned int seed, tl, tr, bl, br, d;
+    float r;
+
+    gdk_threads_enter();
+        w = lookup_widget(widget, &quot;mpd_seed_spinbutton&quot;);
+        seed = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;mpd_tl_spinbutton&quot;);
+        tl = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;mpd_tr_spinbutton&quot;);
+        tr = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;mpd_bl_spinbutton&quot;);
+        bl = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;mpd_br_spinbutton&quot;);
+        br = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;mpd_displacement_spinbutton&quot;);
+        d = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;mpd_roughness_spinbutton&quot;);
+        r = gtk_spin_button_get_value_as_float(GTK_SPIN_BUTTON(w));
+    gdk_threads_leave();
+
+    snprintf(buf, len, &quot;seed=%u:tl=%u:tr=%u:bl=%u:br=%u:d=%u:r=%0.2f&quot;, seed,
+                                                        tl, tr, bl, br, d, r);
+}
+
+static void retrieve_settings_forge(GtkWidget *widget, char *buf, int len) {
+    GtkWidget *w;
+    unsigned int seed;
+    float fracdim, powscale;
+
+    gdk_threads_enter();
+        w = lookup_widget(widget, &quot;forge_seed_spinbutton&quot;);
+        seed = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;forge_fracdim_spinbutton&quot;);
+        fracdim = gtk_spin_button_get_value_as_float(GTK_SPIN_BUTTON(w));
+        w = lookup_widget(widget, &quot;forge_powscale_spinbutton&quot;);
+        powscale = gtk_spin_button_get_value_as_float(GTK_SPIN_BUTTON(w));
+    gdk_threads_leave();
+
+    snprintf(buf, len, &quot;seed=%u:fracdim=%0.2f:powscale=%0.2f&quot;, seed, fracdim,
+                                                                powscale);
+}
+
+#define BUFSIZE 512
+static char *retrieve_settings(GtkWidget *widget, int which) {
+    static char settings[BUFSIZE];
+    void (*retrieve[])(GtkWidget *widget, char *buf, int len) = {
+        retrieve_settings_ff,
+        retrieve_settings_mpd,
+        retrieve_settings_forge
+    };
+    retrieve[which](widget, settings, BUFSIZE);
+    return settings;
+}
+
+static void *generate_thread(void *args) {
+    GtkWidget *widget;
+    gint active;
+    unsigned int dims[] = { 3, 5, 9, 17, 33, 65, 129, 257, 513, 1025, 2049, 4097, 8193, 16385 };
+    unsigned int normmin, normmax, normfirst, normlast, inv, blurx, blury;
+    unsigned int blur;
+    double blursigma;
+    char *settings;
+ 
+    if (!main_progressbar) {
+        gdk_threads_enter();
+            widget = lookup_widget(GTK_WIDGET(args), &quot;main_progressbar&quot;);
+            main_progressbar = GTK_PROGRESS_BAR(widget);
+        gdk_threads_leave();
+    }
+ 
+    hmg_progress_meter = gui_progress_meter;
+    gdk_threads_enter();
+        widget = lookup_widget(GTK_WIDGET(args), &quot;size_combobox&quot;);
+        active = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+    gdk_threads_leave();
+    map_width = map_height = dims[active];
+
+    if (map_pixbuf) {
+        gdk_threads_enter();
+            g_object_unref(map_pixbuf);
+            map_pixbuf = NULL;
+        gdk_threads_leave();
+    }
+
+    map     = realloc(map,     map_width * map_height);
+    tempmap = realloc(tempmap, map_width * map_height);
+
+    if (!map || !tempmap) {
+        gui_progress_meter(&quot;Out of memory!&quot;, 42);
+        goto stopit;
+    }
+
+    gdk_threads_enter();
+        widget = lookup_widget(GTK_WIDGET(args), &quot;algorithm_combobox&quot;);
+        active = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+    gdk_threads_leave();
+
+    settings = retrieve_settings(args, active);
+    hmg_parse_params(settings, hmg_algorithms[active]-&gt;params);
+    hmg_algorithms[active]-&gt;func(map, tempmap, map_width, map_height);
+
+    // post-processing
+
+    gdk_threads_enter();
+        widget = lookup_widget(GTK_WIDGET(args), &quot;norm_first_checkbutton&quot;);
+        normfirst = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;norm_last_checkbutton&quot;);
+        normlast = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;norm_min_spinbutton&quot;);
+        normmin = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;norm_max_spinbutton&quot;);
+        normmax = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;invert_checkbutton&quot;);
+        inv = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;blur_checkbutton&quot;);
+        blur = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;blur_xradius_spinbutton&quot;);
+        blurx = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;blur_yradius_spinbutton&quot;);
+        blury = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget));
+        widget = lookup_widget(GTK_WIDGET(args), &quot;blur_sigma_spinbutton&quot;);
+        blursigma = gtk_spin_button_get_value_as_float(GTK_SPIN_BUTTON(widget));
+    gdk_threads_leave();
+
+    if (normfirst)
+        hmg_normalize(map, normmin, normmax, map_width, map_height);
+
+    if (blur)
+        hmg_gaussian_blur(map, tempmap, blurx, blury, blursigma, map_width,
+                                                                map_height);
+    if (normlast)
+        hmg_normalize(map, normmin, normmax, map_width, map_height);
+
+    if (inv)
+        hmg_invert(map, map_width, map_height);
+
+    if (tempmap)
+        free(tempmap);
+    tempmap = NULL;
+
+    render_map(args);
+
+stopit:
+    gdk_threads_enter();
+        widget = lookup_widget(GTK_WIDGET(args), &quot;main_notebook&quot;);
+        gtk_widget_set_sensitive (widget, TRUE);
+        gtk_notebook_set_current_page(GTK_NOTEBOOK(widget), 0);
+    gdk_threads_leave();
+
+    return NULL;
+}
+
+void on_generate_button_clicked(GtkButton *button, gpointer user_data) {
+    GtkWidget *widget = lookup_widget(GTK_WIDGET(button), &quot;main_notebook&quot;);
+
+    gtk_widget_set_sensitive (widget, FALSE);
+
+    g_thread_create(generate_thread, button, FALSE, NULL);
+}
+
+void on_pgm_save_as_button_clicked(GtkButton *button, gpointer user_data) {
+}
+
+
+void on_ppm_save_as_button_clicked(GtkButton *button, gpointer user_data) {
+}
+
+gboolean on_view_drawingarea_expose_event(GtkWidget *widget,
+                                          GdkEventExpose *event,
+                                          gpointer user_data) {
+    GdkDrawable *drawable = widget-&gt;window;
+    GdkGC *gc = widget-&gt;style-&gt;fg_gc[GTK_WIDGET_STATE (widget)];
+    gint width, height;
+
+    if (!map_pixbuf)
+        return FALSE;
+
+    width = gdk_pixbuf_get_width(map_pixbuf);
+    height = gdk_pixbuf_get_height(map_pixbuf);
+
+    gtk_widget_set_size_request(widget, width, height);
+
+    gdk_draw_pixbuf(drawable, gc, map_pixbuf, 0, 0, 0, 0, width, height,
+            GDK_RGB_DITHER_NONE, 0, 0);
+
+    return FALSE;
+}
+
+void gui_quit(GtkWidget *widget, gpointer user_data) {
+    if (map_pixbuf)
+        g_object_unref(map_pixbuf);
+    if (map)
+        free(map);
+    if (tempmap)
+        free(tempmap);
+
+    gtk_main_quit();
+}
+
+void on_new_create_button_clicked(GtkButton *button, gpointer user_data) {
+}
+
+void on_norm2_button_clicked(GtkButton *button, gpointer user_data) {
+}
+
+void on_blur2_button_clicked(GtkButton *button, gpointer user_data) {
+}
+
+void on_invert2_button_clicked(GtkButton *button, gpointer user_data) {
+}
+
+gboolean on_colormap_display_expose_event(GtkWidget *widget,
+                                          GdkEventExpose *event,
+                                          gpointer user_data) {
+    GdkDrawable *drawable = widget-&gt;window;
+    GdkGC *gc = gdk_gc_new(drawable);
+    unsigned int width = 514, height = 32, x;
+    GdkColor ourcolor = { 0, 0, 0, 0 };
+
+    gtk_widget_set_size_request(widget, width, height);
+
+    gdk_gc_set_foreground(gc, &amp;ourcolor);
+    gdk_draw_rectangle(drawable, gc, TRUE, 0, 0, width, height);
+
+    for (x=0; x&lt;256; x++) {
+        ourcolor.pixel = (hmg_colormap[x][0]&lt;&lt;16) +
+                         (hmg_colormap[x][1]&lt;&lt;8)  +
+                          hmg_colormap[x][2];
+        gdk_gc_set_foreground(gc, &amp;ourcolor);
+        gdk_draw_rectangle(drawable, gc, FALSE, 1+2*x, 1, 1, height-3);
+    }
+
+    g_object_unref(gc);
+    return FALSE;
+}
+

Added: trunk/gui_callbacks.h
===================================================================
--- trunk/gui_callbacks.h	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_callbacks.h	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,24 @@
+#ifndef HMG_GUI_CALLBACKS_H
+#define HMG_GUI_CALLBACKS_H
+
+#include &lt;gtk/gtk.h&gt;
+
+void gui_quit(GtkWidget *widget, gpointer user_data);
+
+void on_algorithm_combobox_changed(GtkComboBox *combobox, gpointer user_data);
+void on_size_combobox_changed     (GtkComboBox *combobox, gpointer user_data);
+
+void on_generate_button_clicked   (GtkButton *button, gpointer user_data);
+void on_pgm_save_as_button_clicked(GtkButton *button, gpointer user_data);
+void on_ppm_save_as_button_clicked(GtkButton *button, gpointer user_data);
+void on_new_create_button_clicked (GtkButton *button, gpointer user_data);
+void on_norm2_button_clicked      (GtkButton *button, gpointer user_data);
+void on_blur2_button_clicked      (GtkButton *button, gpointer user_data);
+void on_invert2_button_clicked    (GtkButton *button, gpointer user_data);
+
+gboolean on_view_drawingarea_expose_event (GtkWidget *widget,
+                                    GdkEventExpose *event, gpointer user_data);
+gboolean on_colormap_display_expose_event (GtkWidget *widget,
+                                    GdkEventExpose *event, gpointer user_data);
+
+#endif

Added: trunk/gui_interface.c
===================================================================
--- trunk/gui_interface.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_interface.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,1000 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtk/gtk.h&gt;
+#include &quot;gui_callbacks.h&quot;
+#include &quot;gui_interface.h&quot;
+#include &quot;gui_support.h&quot;
+
+#define GLADE_HOOKUP_OBJECT(component,widget,name) \
+  g_object_set_data_full (G_OBJECT (component), name, \
+    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
+
+#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
+  g_object_set_data (G_OBJECT (component), name, widget)
+
+GtkWidget * create_hmgengui(void) {
+  GtkWidget *hmgengui, *vbox1, *main_notebook;
+  GtkWidget *view_scrolledwindow, *viewport1, *view_drawingarea, *view_label;
+  GtkWidget *vbox3, *frame1, *alignment1, *hbox1, *label9, *algorithm_combobox;
+  GtkWidget *label10, *size_combobox, *generate_button, *label6, *frame2;
+  GtkWidget *alignment2, *postprocessing_notebook, *table7, *label26, *label27;
+  GtkWidget *norm_min_spinbutton, *norm_max_spinbutton;
+  GtkWidget *norm_first_checkbutton, *norm_last_checkbutton;
+  GtkWidget *normalize_label, *table5, *blur_checkbutton, *label28, *label29;
+  GtkWidget *label30, *blur_sigma_spinbutton, *blur_yradius_spinbutton;
+  GtkWidget *blur_xradius_spinbutton, *blur_label, *table6;
+  GtkWidget *invert_checkbutton, *invert_label, *label7, *frame3;
+  GtkWidget *alignment3, *algosettings_notebook, *table1, *label11, *label12;
+  GtkWidget *label13, *label14, *label15, *ff_seed_spinbutton;
+  GtkWidget *ff_init_spinbutton, *ff_nplates_spinbutton;
+  GtkWidget *ff_upfactor_spinbutton, *ff_downfactor_spinbutton;
+  GtkWidget *ff_label, *table3, *label16, *label17, *label18, *label19;
+  GtkWidget *label20, *label21, *label22, *mpd_roughness_spinbutton;
+  GtkWidget *mpd_displacement_spinbutton, *mpd_br_spinbutton;
+  GtkWidget *mpd_bl_spinbutton, *mpd_tr_spinbutton, *mpd_tl_spinbutton;
+  GtkWidget *mpd_seed_spinbutton, *mpd_label, *table4, *label23, *label24;
+  GtkWidget *label25, *forge_seed_spinbutton, *forge_fracdim_spinbutton;
+  GtkWidget *forge_powscale_spinbutton, *forge_label, *label8, *generate_label;
+  GtkWidget *table8, *label31, *label32, *pgm_save_as_button, *alignment4;
+  GtkWidget *hbox3, *image1, *label33, *ppm_save_as_button, *alignment5;
+  GtkWidget *hbox4, *image2, *label34, *save_label, *vbox4, *image3;
+  GtkWidget *about_message, *about_label, *main_progressbar;
+  GtkWidget *hbox5, *view_sidepanel_notebook, *table9, *label39, *label40;
+  GtkWidget *new_width_spinbutton, *new_height_spinbutton, *new_create_button;
+  GtkWidget *label35, *table10, *label36, *table11, *label37, *table12;
+  GtkWidget *label38, *label41, *new_level_spinbutton, *table13, *label42;
+  GtkWidget *label43, *label44, *norm2_min_spinbutton, *norm2_max_spinbutton;
+  GtkWidget *norm2_button, *label45, *label46, *label47, *vbox5, *hbox7;
+  GtkWidget *blur2_xrad_spinbutton, *blur2_yrad_spinbutton, *colormap_display;
+  GtkWidget *blur2_sigma_spinbutton, *blur2_button, *label48, *invert2_button;
+  GtkWidget *label49, *table14;
+
+  GtkObject *norm_min_spinbutton_adj, *norm_max_spinbutton_adj;
+  GtkObject *blur_sigma_spinbutton_adj, *blur_yradius_spinbutton_adj;
+  GtkObject *blur_xradius_spinbutton_adj, *ff_seed_spinbutton_adj;
+  GtkObject *ff_init_spinbutton_adj, *ff_nplates_spinbutton_adj;
+  GtkObject *ff_upfactor_spinbutton_adj, *ff_downfactor_spinbutton_adj;
+  GtkObject *mpd_roughness_spinbutton_adj, *mpd_displacement_spinbutton_adj;
+  GtkObject *mpd_br_spinbutton_adj, *mpd_bl_spinbutton_adj;
+  GtkObject *mpd_tr_spinbutton_adj, *mpd_tl_spinbutton_adj;
+  GtkObject *mpd_seed_spinbutton_adj, *forge_seed_spinbutton_adj;
+  GtkObject *forge_fracdim_spinbutton_adj, *forge_powscale_spinbutton_adj;
+  GtkObject *new_width_spinbutton_adj, *new_height_spinbutton_adj;
+  GtkObject *new_level_spinbutton_adj, *norm2_min_spinbutton_adj;
+  GtkObject *norm2_max_spinbutton_adj, *blur2_xrad_spinbutton_adj;
+  GtkObject *blur2_yrad_spinbutton_adj, *blur2_sigma_spinbutton_adj;
+
+  hmgengui = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+//  gtk_widget_set_size_request (hmgengui, 800, -1);
+  gtk_window_set_title (GTK_WINDOW (hmgengui), &quot;hmgengui&quot;);
+
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_container_add (GTK_CONTAINER (hmgengui), vbox1);
+//  gtk_widget_set_sensitive (vbox1, FALSE);
+
+  main_notebook = gtk_notebook_new ();
+  gtk_widget_show (main_notebook);
+  gtk_box_pack_start (GTK_BOX (vbox1), main_notebook, TRUE, TRUE, 0);
+
+  hbox5 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox5);
+  gtk_container_add (GTK_CONTAINER (main_notebook), hbox5);
+
+  view_sidepanel_notebook = gtk_notebook_new ();
+  gtk_widget_show (view_sidepanel_notebook);
+  gtk_box_pack_start (GTK_BOX (hbox5), view_sidepanel_notebook, FALSE, TRUE, 0);
+  gtk_notebook_set_show_border (GTK_NOTEBOOK (view_sidepanel_notebook), FALSE);
+  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (view_sidepanel_notebook), GTK_POS_LEFT);
+
+  table9 = gtk_table_new (5, 3, FALSE);
+  gtk_widget_show (table9);
+  gtk_container_add (GTK_CONTAINER (view_sidepanel_notebook), table9);
+  gtk_container_set_border_width (GTK_CONTAINER (table9), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table9), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table9), 8);
+
+  label39 = gtk_label_new (&quot;Width&quot;);
+  gtk_widget_show (label39);
+  gtk_table_attach (GTK_TABLE (table9), label39, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label39), 0, 0.5);
+
+  label40 = gtk_label_new (&quot;Height&quot;);
+  gtk_widget_show (label40);
+  gtk_table_attach (GTK_TABLE (table9), label40, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label40), 0, 0.5);
+
+  new_width_spinbutton_adj = gtk_adjustment_new (513, 1, 16385, 1, 10, 10);
+  new_width_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (new_width_spinbutton_adj), 1, 0);
+  gtk_widget_show (new_width_spinbutton);
+  gtk_table_attach (GTK_TABLE (table9), new_width_spinbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  new_height_spinbutton_adj = gtk_adjustment_new (513, 1, 16385, 1, 10, 10);
+  new_height_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (new_height_spinbutton_adj), 1, 0);
+  gtk_widget_show (new_height_spinbutton);
+  gtk_table_attach (GTK_TABLE (table9), new_height_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  new_create_button = gtk_button_new_with_mnemonic (&quot;Create&quot;);
+  gtk_widget_show (new_create_button);
+  gtk_table_attach (GTK_TABLE (table9), new_create_button, 1, 2, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label41 = gtk_label_new (&quot;Level&quot;);
+  gtk_widget_show (label41);
+  gtk_table_attach (GTK_TABLE (table9), label41, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label41), 0, 0.5);
+
+  new_level_spinbutton_adj = gtk_adjustment_new (128, 0, 255, 1, 10, 10);
+  new_level_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (new_level_spinbutton_adj), 1, 0);
+  gtk_widget_show (new_level_spinbutton);
+  gtk_table_attach (GTK_TABLE (table9), new_level_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label35 = gtk_label_new (&quot;New&quot;);
+  gtk_widget_show (label35);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (view_sidepanel_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (view_sidepanel_notebook), 0), label35);
+
+  table10 = gtk_table_new (4, 3, FALSE);
+  gtk_widget_show (table10);
+  gtk_container_add (GTK_CONTAINER (view_sidepanel_notebook), table10);
+  gtk_container_set_border_width (GTK_CONTAINER (table10), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table10), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table10), 8);
+
+  label43 = gtk_label_new (&quot;Minimum&quot;);
+  gtk_widget_show (label43);
+  gtk_table_attach (GTK_TABLE (table10), label43, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label43), 0, 0.5);
+
+  label44 = gtk_label_new (&quot;Maximum&quot;);
+  gtk_widget_show (label44);
+  gtk_table_attach (GTK_TABLE (table10), label44, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label44), 0, 0.5);
+
+  norm2_min_spinbutton_adj = gtk_adjustment_new (0, 0, 255, 1, 10, 10);
+  norm2_min_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (norm2_min_spinbutton_adj), 1, 0);
+  gtk_widget_show (norm2_min_spinbutton);
+  gtk_table_attach (GTK_TABLE (table10), norm2_min_spinbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  norm2_max_spinbutton_adj = gtk_adjustment_new (255, 0, 255, 1, 10, 10);
+  norm2_max_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (norm2_max_spinbutton_adj), 1, 0);
+  gtk_widget_show (norm2_max_spinbutton);
+  gtk_table_attach (GTK_TABLE (table10), norm2_max_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  norm2_button = gtk_button_new_with_mnemonic (&quot;Normalize&quot;);
+  gtk_widget_show (norm2_button);
+  gtk_table_attach (GTK_TABLE (table10), norm2_button, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label36 = gtk_label_new (&quot;Normalize&quot;);
+  gtk_widget_show (label36);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (view_sidepanel_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (view_sidepanel_notebook), 1), label36);
+
+  table11 = gtk_table_new (5, 3, FALSE);
+  gtk_widget_show (table11);
+  gtk_container_add (GTK_CONTAINER (view_sidepanel_notebook), table11);
+  gtk_container_set_border_width (GTK_CONTAINER (table11), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table11), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table11), 8);
+
+  label45 = gtk_label_new (&quot;X Radius&quot;);
+  gtk_widget_show (label45);
+  gtk_table_attach (GTK_TABLE (table11), label45, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label45), 0, 0.5);
+
+  label46 = gtk_label_new (&quot;Y Radius&quot;);
+  gtk_widget_show (label46);
+  gtk_table_attach (GTK_TABLE (table11), label46, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label46), 0, 0.5);
+
+  label47 = gtk_label_new (&quot;Sigma&quot;);
+  gtk_widget_show (label47);
+  gtk_table_attach (GTK_TABLE (table11), label47, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label47), 0, 0.5);
+
+  blur2_xrad_spinbutton_adj = gtk_adjustment_new (3, 1, 128, 1, 10, 10);
+  blur2_xrad_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (blur2_xrad_spinbutton_adj), 1, 0);
+  gtk_widget_show (blur2_xrad_spinbutton);
+  gtk_table_attach (GTK_TABLE (table11), blur2_xrad_spinbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  blur2_yrad_spinbutton_adj = gtk_adjustment_new (3, 1, 128, 1, 10, 10);
+  blur2_yrad_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (blur2_yrad_spinbutton_adj), 1, 0);
+  gtk_widget_show (blur2_yrad_spinbutton);
+  gtk_table_attach (GTK_TABLE (table11), blur2_yrad_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  blur2_sigma_spinbutton_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
+  blur2_sigma_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (blur2_sigma_spinbutton_adj), 1, 2);
+  gtk_widget_show (blur2_sigma_spinbutton);
+  gtk_table_attach (GTK_TABLE (table11), blur2_sigma_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  blur2_button = gtk_button_new_with_mnemonic (&quot;Blur&quot;);
+  gtk_widget_show (blur2_button);
+  gtk_table_attach (GTK_TABLE (table11), blur2_button, 1, 2, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label37 = gtk_label_new (&quot;Blur&quot;);
+  gtk_widget_show (label37);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (view_sidepanel_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (view_sidepanel_notebook), 2), label37);
+
+  table12 = gtk_table_new (3, 3, FALSE);
+  gtk_widget_show (table12);
+  gtk_container_add (GTK_CONTAINER (view_sidepanel_notebook), table12);
+  gtk_container_set_border_width (GTK_CONTAINER (table12), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table12), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table12), 8);
+
+  label48 = gtk_label_new (&quot;          &quot;);
+  gtk_widget_show (label48);
+  gtk_table_attach (GTK_TABLE (table12), label48, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label48), 0, 0.5);
+
+  invert2_button = gtk_button_new_with_mnemonic (&quot;Invert&quot;);
+  gtk_widget_show (invert2_button);
+  gtk_table_attach (GTK_TABLE (table12), invert2_button, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label38 = gtk_label_new (&quot;Invert&quot;);
+  gtk_widget_show (label38);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (view_sidepanel_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (view_sidepanel_notebook), 3), label38);
+
+  view_scrolledwindow = gtk_scrolled_window_new (NULL, NULL);
+  gtk_widget_show (view_scrolledwindow);
+  gtk_box_pack_start (GTK_BOX (hbox5), view_scrolledwindow, TRUE, TRUE, 0);
+
+  viewport1 = gtk_viewport_new (NULL, NULL);
+  gtk_widget_show (viewport1);
+  gtk_container_add (GTK_CONTAINER (view_scrolledwindow), viewport1);
+
+  view_drawingarea = gtk_drawing_area_new ();
+  gtk_widget_show (view_drawingarea);
+  gtk_container_add (GTK_CONTAINER (viewport1), view_drawingarea);
+
+  view_label = gtk_label_new (&quot;2D View&quot;);
+  gtk_widget_show (view_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (main_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (main_notebook), 0), view_label);
+
+  vbox3 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox3);
+  gtk_container_add (GTK_CONTAINER (main_notebook), vbox3);
+
+  frame1 = gtk_frame_new (NULL);
+  gtk_widget_show (frame1);
+  gtk_box_pack_start (GTK_BOX (vbox3), frame1, FALSE, FALSE, 0);
+  gtk_container_set_border_width (GTK_CONTAINER (frame1), 8);
+
+  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment1);
+  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
+  gtk_container_set_border_width (GTK_CONTAINER (alignment1), 8);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 0, 0, 12, 0);
+
+  hbox1 = gtk_hbox_new (FALSE, 8);
+  gtk_widget_show (hbox1);
+  gtk_container_add (GTK_CONTAINER (alignment1), hbox1);
+
+  label9 = gtk_label_new (&quot;Algorithm&quot;);
+  gtk_widget_show (label9);
+  gtk_box_pack_start (GTK_BOX (hbox1), label9, FALSE, FALSE, 0);
+
+  algorithm_combobox = gtk_combo_box_new_text ();
+  gtk_widget_show (algorithm_combobox);
+  gtk_box_pack_start (GTK_BOX (hbox1), algorithm_combobox, FALSE, FALSE, 0);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (algorithm_combobox), &quot;Fault Formation&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (algorithm_combobox), &quot;Midpoint Displacement (plasma)&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (algorithm_combobox), &quot;Forge (ppmforge/gforge/fft'd noise)&quot;);
+
+  label10 = gtk_label_new (&quot;Size&quot;);
+  gtk_widget_show (label10);
+  gtk_box_pack_start (GTK_BOX (hbox1), label10, FALSE, FALSE, 0);
+
+  size_combobox = gtk_combo_box_new_text ();
+  gtk_widget_show (size_combobox);
+  gtk_box_pack_start (GTK_BOX (hbox1), size_combobox, FALSE, FALSE, 0);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;3 x 3&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;5 x 5&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;9 x 9&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;17 x 17&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;33 x 33&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;65 x 65&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;129 x 129&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;257 x 257&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;513 x 513&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;1025 x 1025&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;2049 x 2049&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;4097 x 4097&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;8193 x 8193&quot;);
+  gtk_combo_box_append_text (GTK_COMBO_BOX (size_combobox), &quot;16385 x 16384&quot;);
+
+  generate_button = gtk_button_new_with_mnemonic (&quot;Generate!&quot;);
+  gtk_widget_show (generate_button);
+  gtk_box_pack_start (GTK_BOX (hbox1), generate_button, FALSE, FALSE, 0);
+  gtk_widget_set_sensitive (generate_button, FALSE);
+
+  label6 = gtk_label_new (&quot;Main&quot;);
+  gtk_widget_show (label6);
+  gtk_frame_set_label_widget (GTK_FRAME (frame1), label6);
+  gtk_label_set_use_markup (GTK_LABEL (label6), TRUE);
+
+  frame2 = gtk_frame_new (NULL);
+  gtk_widget_show (frame2);
+  gtk_box_pack_start (GTK_BOX (vbox3), frame2, FALSE, FALSE, 0);
+  gtk_container_set_border_width (GTK_CONTAINER (frame2), 8);
+
+  alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment2);
+  gtk_container_add (GTK_CONTAINER (frame2), alignment2);
+  gtk_container_set_border_width (GTK_CONTAINER (alignment2), 8);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 0, 0, 12, 0);
+
+  postprocessing_notebook = gtk_notebook_new ();
+  gtk_widget_show (postprocessing_notebook);
+  gtk_container_add (GTK_CONTAINER (alignment2), postprocessing_notebook);
+
+  table7 = gtk_table_new (4, 4, FALSE);
+  gtk_widget_show (table7);
+  gtk_container_add (GTK_CONTAINER (postprocessing_notebook), table7);
+  gtk_container_set_border_width (GTK_CONTAINER (table7), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table7), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table7), 8);
+
+  label26 = gtk_label_new (&quot;Minimum&quot;);
+  gtk_widget_show (label26);
+  gtk_table_attach (GTK_TABLE (table7), label26, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label26), 0, 0.5);
+
+  label27 = gtk_label_new (&quot;Maximum&quot;);
+  gtk_widget_show (label27);
+  gtk_table_attach (GTK_TABLE (table7), label27, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label27), 0, 0.5);
+
+  norm_min_spinbutton_adj = gtk_adjustment_new (0, 0, 255, 1, 10, 10);
+  norm_min_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (norm_min_spinbutton_adj), 1, 0);
+  gtk_widget_show (norm_min_spinbutton);
+  gtk_table_attach (GTK_TABLE (table7), norm_min_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  norm_max_spinbutton_adj = gtk_adjustment_new (255, 0, 255, 1, 10, 10);
+  norm_max_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (norm_max_spinbutton_adj), 1, 0);
+  gtk_widget_show (norm_max_spinbutton);
+  gtk_table_attach (GTK_TABLE (table7), norm_max_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  norm_first_checkbutton = gtk_check_button_new_with_mnemonic (&quot;First&quot;);
+  gtk_widget_show (norm_first_checkbutton);
+  gtk_table_attach (GTK_TABLE (table7), norm_first_checkbutton, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  norm_last_checkbutton = gtk_check_button_new_with_mnemonic (&quot;Last&quot;);
+  gtk_widget_show (norm_last_checkbutton);
+  gtk_table_attach (GTK_TABLE (table7), norm_last_checkbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  normalize_label = gtk_label_new (&quot;Normalize&quot;);
+  gtk_widget_show (normalize_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (postprocessing_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (postprocessing_notebook), 0), normalize_label);
+
+  table5 = gtk_table_new (5, 3, FALSE);
+  gtk_widget_show (table5);
+  gtk_container_add (GTK_CONTAINER (postprocessing_notebook), table5);
+  gtk_container_set_border_width (GTK_CONTAINER (table5), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table5), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table5), 8);
+
+  blur_checkbutton = gtk_check_button_new_with_mnemonic (&quot;Enable&quot;);
+  gtk_widget_show (blur_checkbutton);
+  gtk_table_attach (GTK_TABLE (table5), blur_checkbutton, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  label28 = gtk_label_new (&quot;X Radius&quot;);
+  gtk_widget_show (label28);
+  gtk_table_attach (GTK_TABLE (table5), label28, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label28), 0, 0.5);
+
+  label29 = gtk_label_new (&quot;Y Radius&quot;);
+  gtk_widget_show (label29);
+  gtk_table_attach (GTK_TABLE (table5), label29, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label29), 0, 0.5);
+
+  label30 = gtk_label_new (&quot;Sigma&quot;);
+  gtk_widget_show (label30);
+  gtk_table_attach (GTK_TABLE (table5), label30, 0, 1, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label30), 0, 0.5);
+
+  blur_sigma_spinbutton_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
+  blur_sigma_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (blur_sigma_spinbutton_adj), 1, 2);
+  gtk_widget_show (blur_sigma_spinbutton);
+  gtk_table_attach (GTK_TABLE (table5), blur_sigma_spinbutton, 1, 2, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  blur_yradius_spinbutton_adj = gtk_adjustment_new (3, 1, 128, 1, 10, 10);
+  blur_yradius_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (blur_yradius_spinbutton_adj), 1, 0);
+  gtk_widget_show (blur_yradius_spinbutton);
+  gtk_table_attach (GTK_TABLE (table5), blur_yradius_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  blur_xradius_spinbutton_adj = gtk_adjustment_new (3, 1, 128, 1, 10, 10);
+  blur_xradius_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (blur_xradius_spinbutton_adj), 1, 0);
+  gtk_widget_show (blur_xradius_spinbutton);
+  gtk_table_attach (GTK_TABLE (table5), blur_xradius_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  blur_label = gtk_label_new (&quot;Blur&quot;);
+  gtk_widget_show (blur_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (postprocessing_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (postprocessing_notebook), 1), blur_label);
+
+  table6 = gtk_table_new (2, 2, FALSE);
+  gtk_widget_show (table6);
+  gtk_container_add (GTK_CONTAINER (postprocessing_notebook), table6);
+  gtk_container_set_border_width (GTK_CONTAINER (table6), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table6), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table6), 8);
+
+  invert_checkbutton = gtk_check_button_new_with_mnemonic (&quot;Enable&quot;);
+  gtk_widget_show (invert_checkbutton);
+  gtk_table_attach (GTK_TABLE (table6), invert_checkbutton, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  invert_label = gtk_label_new (&quot;Invert&quot;);
+  gtk_widget_show (invert_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (postprocessing_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (postprocessing_notebook), 2), invert_label);
+
+  label7 = gtk_label_new (&quot;Postprocessing&quot;);
+  gtk_widget_show (label7);
+  gtk_frame_set_label_widget (GTK_FRAME (frame2), label7);
+  gtk_label_set_use_markup (GTK_LABEL (label7), TRUE);
+
+  frame3 = gtk_frame_new (NULL);
+  gtk_widget_show (frame3);
+  gtk_box_pack_start (GTK_BOX (vbox3), frame3, FALSE, FALSE, 0);
+  gtk_container_set_border_width (GTK_CONTAINER (frame3), 8);
+
+  alignment3 = gtk_alignment_new (0.5, 0.5, 1, 1);
+  gtk_widget_show (alignment3);
+  gtk_container_add (GTK_CONTAINER (frame3), alignment3);
+  gtk_container_set_border_width (GTK_CONTAINER (alignment3), 8);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment3), 0, 0, 12, 0);
+
+  algosettings_notebook = gtk_notebook_new ();
+  gtk_notebook_set_show_tabs(GTK_NOTEBOOK(algosettings_notebook), FALSE);
+  gtk_widget_show (algosettings_notebook);
+  gtk_container_add (GTK_CONTAINER (alignment3), algosettings_notebook);
+
+  table1 = gtk_table_new (6, 3, FALSE);
+  gtk_widget_show (table1);
+  gtk_container_add (GTK_CONTAINER (algosettings_notebook), table1);
+  gtk_container_set_border_width (GTK_CONTAINER (table1), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table1), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table1), 8);
+
+  label11 = gtk_label_new (&quot;Seed&quot;);
+  gtk_widget_show (label11);
+  gtk_table_attach (GTK_TABLE (table1), label11, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label11), 0, 0.5);
+
+  label12 = gtk_label_new (&quot;Initial Height&quot;);
+  gtk_widget_show (label12);
+  gtk_table_attach (GTK_TABLE (table1), label12, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label12), 0, 0.5);
+
+  label13 = gtk_label_new (&quot;Number of Plates&quot;);
+  gtk_widget_show (label13);
+  gtk_table_attach (GTK_TABLE (table1), label13, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label13), 0, 0.5);
+
+  label14 = gtk_label_new (&quot;Up Factor&quot;);
+  gtk_widget_show (label14);
+  gtk_table_attach (GTK_TABLE (table1), label14, 0, 1, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label14), 0, 0.5);
+
+  label15 = gtk_label_new (&quot;Down Factor&quot;);
+  gtk_widget_show (label15);
+  gtk_table_attach (GTK_TABLE (table1), label15, 0, 1, 4, 5,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label15), 0, 0.5);
+
+  ff_seed_spinbutton_adj = gtk_adjustment_new (42, 0, 2147469952, 1, 10, 10);
+  ff_seed_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (ff_seed_spinbutton_adj), 1, 0);
+  gtk_widget_show (ff_seed_spinbutton);
+  gtk_table_attach (GTK_TABLE (table1), ff_seed_spinbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  ff_init_spinbutton_adj = gtk_adjustment_new (128, 0, 255, 1, 10, 10);
+  ff_init_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (ff_init_spinbutton_adj), 1, 0);
+  gtk_widget_show (ff_init_spinbutton);
+  gtk_table_attach (GTK_TABLE (table1), ff_init_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  ff_nplates_spinbutton_adj = gtk_adjustment_new (512, 1, 65536, 1, 10, 10);
+  ff_nplates_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (ff_nplates_spinbutton_adj), 1, 0);
+  gtk_widget_show (ff_nplates_spinbutton);
+  gtk_table_attach (GTK_TABLE (table1), ff_nplates_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  ff_upfactor_spinbutton_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
+  ff_upfactor_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (ff_upfactor_spinbutton_adj), 1, 0);
+  gtk_widget_show (ff_upfactor_spinbutton);
+  gtk_table_attach (GTK_TABLE (table1), ff_upfactor_spinbutton, 1, 2, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  ff_downfactor_spinbutton_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
+  ff_downfactor_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (ff_downfactor_spinbutton_adj), 1, 0);
+  gtk_widget_show (ff_downfactor_spinbutton);
+  gtk_table_attach (GTK_TABLE (table1), ff_downfactor_spinbutton, 1, 2, 4, 5,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  ff_label = gtk_label_new (&quot;FF&quot;);
+  gtk_widget_show (ff_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (algosettings_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (algosettings_notebook), 0), ff_label);
+
+  table3 = gtk_table_new (8, 3, FALSE);
+  gtk_widget_show (table3);
+  gtk_container_add (GTK_CONTAINER (algosettings_notebook), table3);
+  gtk_container_set_border_width (GTK_CONTAINER (table3), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table3), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table3), 8);
+
+  label16 = gtk_label_new (&quot;Seed&quot;);
+  gtk_widget_show (label16);
+  gtk_table_attach (GTK_TABLE (table3), label16, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label16), 0, 0.5);
+
+  label17 = gtk_label_new (&quot;Top Left&quot;);
+  gtk_widget_show (label17);
+  gtk_table_attach (GTK_TABLE (table3), label17, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label17), 0, 0.5);
+
+  label18 = gtk_label_new (&quot;Top Right&quot;);
+  gtk_widget_show (label18);
+  gtk_table_attach (GTK_TABLE (table3), label18, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label18), 0, 0.5);
+
+  label19 = gtk_label_new (&quot;Bottom Left&quot;);
+  gtk_widget_show (label19);
+  gtk_table_attach (GTK_TABLE (table3), label19, 0, 1, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label19), 0, 0.5);
+
+  label20 = gtk_label_new (&quot;Bottom Right&quot;);
+  gtk_widget_show (label20);
+  gtk_table_attach (GTK_TABLE (table3), label20, 0, 1, 4, 5,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label20), 0, 0.5);
+
+  label21 = gtk_label_new (&quot;Displacement&quot;);
+  gtk_widget_show (label21);
+  gtk_table_attach (GTK_TABLE (table3), label21, 0, 1, 5, 6,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label21), 0, 0.5);
+
+  label22 = gtk_label_new (&quot;Roughness&quot;);
+  gtk_widget_show (label22);
+  gtk_table_attach (GTK_TABLE (table3), label22, 0, 1, 6, 7,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label22), 0, 0.5);
+
+  mpd_roughness_spinbutton_adj = gtk_adjustment_new (0.6, 0, 2, 0.00999999977648, 0.10000000149, 1);
+  mpd_roughness_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_roughness_spinbutton_adj), 1, 2);
+  gtk_widget_show (mpd_roughness_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_roughness_spinbutton, 1, 2, 6, 7,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_displacement_spinbutton_adj = gtk_adjustment_new (64, 0, 255, 1, 10, 10);
+  mpd_displacement_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_displacement_spinbutton_adj), 1, 0);
+  gtk_widget_show (mpd_displacement_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_displacement_spinbutton, 1, 2, 5, 6,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_br_spinbutton_adj = gtk_adjustment_new (128, 0, 255, 1, 10, 10);
+  mpd_br_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_br_spinbutton_adj), 1, 0);
+  gtk_widget_show (mpd_br_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_br_spinbutton, 1, 2, 4, 5,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_bl_spinbutton_adj = gtk_adjustment_new (128, 0, 255, 1, 10, 10);
+  mpd_bl_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_bl_spinbutton_adj), 1, 0);
+  gtk_widget_show (mpd_bl_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_bl_spinbutton, 1, 2, 3, 4,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_tr_spinbutton_adj = gtk_adjustment_new (128, 0, 255, 1, 10, 10);
+  mpd_tr_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_tr_spinbutton_adj), 1, 0);
+  gtk_widget_show (mpd_tr_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_tr_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_tl_spinbutton_adj = gtk_adjustment_new (128, 0, 255, 1, 10, 10);
+  mpd_tl_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_tl_spinbutton_adj), 1, 0);
+  gtk_widget_show (mpd_tl_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_tl_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_seed_spinbutton_adj = gtk_adjustment_new (42, 0, 2147469952, 1, 10, 10);
+  mpd_seed_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (mpd_seed_spinbutton_adj), 1, 0);
+  gtk_widget_show (mpd_seed_spinbutton);
+  gtk_table_attach (GTK_TABLE (table3), mpd_seed_spinbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  mpd_label = gtk_label_new (&quot;MPD&quot;);
+  gtk_widget_show (mpd_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (algosettings_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (algosettings_notebook), 1), mpd_label);
+
+  table4 = gtk_table_new (4, 3, FALSE);
+  gtk_widget_show (table4);
+  gtk_container_add (GTK_CONTAINER (algosettings_notebook), table4);
+  gtk_container_set_border_width (GTK_CONTAINER (table4), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table4), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table4), 8);
+
+  label23 = gtk_label_new (&quot;Seed&quot;);
+  gtk_widget_show (label23);
+  gtk_table_attach (GTK_TABLE (table4), label23, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label23), 0, 0.5);
+
+  label24 = gtk_label_new (&quot;Fractal Dimension&quot;);
+  gtk_widget_show (label24);
+  gtk_table_attach (GTK_TABLE (table4), label24, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label24), 0, 0.5);
+
+  label25 = gtk_label_new (&quot;Power Scale&quot;);
+  gtk_widget_show (label25);
+  gtk_table_attach (GTK_TABLE (table4), label25, 0, 1, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label25), 0, 0.5);
+
+  forge_seed_spinbutton_adj = gtk_adjustment_new (47, 0, 2147469952, 1, 10, 10);
+  forge_seed_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (forge_seed_spinbutton_adj), 1, 0);
+  gtk_widget_show (forge_seed_spinbutton);
+  gtk_table_attach (GTK_TABLE (table4), forge_seed_spinbutton, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  forge_fracdim_spinbutton_adj = gtk_adjustment_new (2.40000009537, 0, 3, 0.00999999977648, 0.10000000149, 1);
+  forge_fracdim_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (forge_fracdim_spinbutton_adj), 1, 2);
+  gtk_widget_show (forge_fracdim_spinbutton);
+  gtk_table_attach (GTK_TABLE (table4), forge_fracdim_spinbutton, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  forge_powscale_spinbutton_adj = gtk_adjustment_new (1, 0, 8, 0.00999999977648, 0.10000000149, 1);
+  forge_powscale_spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT (forge_powscale_spinbutton_adj), 1, 2);
+  gtk_widget_show (forge_powscale_spinbutton);
+  gtk_table_attach (GTK_TABLE (table4), forge_powscale_spinbutton, 1, 2, 2, 3,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  forge_label = gtk_label_new (&quot;Forge&quot;);
+  gtk_widget_show (forge_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (algosettings_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (algosettings_notebook), 2), forge_label);
+
+  label8 = gtk_label_new (&quot;Algorithm Settings&quot;);
+  gtk_widget_show (label8);
+  gtk_frame_set_label_widget (GTK_FRAME (frame3), label8);
+  gtk_label_set_use_markup (GTK_LABEL (label8), TRUE);
+
+  generate_label = gtk_label_new (&quot;Generate&quot;);
+  gtk_widget_show (generate_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (main_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (main_notebook), 1), generate_label);
+
+  vbox5 = gtk_vbox_new (FALSE, 8);
+  gtk_widget_show (vbox5);
+  gtk_container_add (GTK_CONTAINER (main_notebook), vbox5);
+  gtk_container_set_border_width (GTK_CONTAINER (vbox5), 8);
+
+  hbox7 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox7);
+  gtk_box_pack_start (GTK_BOX (vbox5), hbox7, FALSE, FALSE, 0);
+
+  colormap_display = gtk_drawing_area_new();
+  gtk_widget_show (colormap_display);
+  gtk_box_pack_start (GTK_BOX (hbox7), colormap_display, FALSE, FALSE, 0);
+  gtk_widget_set_size_request (colormap_display, 258, 32);
+
+  table14 = gtk_table_new (3, 3, FALSE);
+  gtk_widget_show (table14);
+  gtk_box_pack_start (GTK_BOX (vbox5), table14, TRUE, TRUE, 0);
+
+  label49 = gtk_label_new (&quot;Colormap&quot;);
+  gtk_widget_show (label49);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (main_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (main_notebook), 2), label49);
+
+  table13 = gtk_table_new (3, 3, FALSE);
+  gtk_widget_show (table13);
+  gtk_container_add (GTK_CONTAINER (main_notebook), table13);
+
+  label42 = gtk_label_new (&quot;Import&quot;);
+  gtk_widget_show (label42);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (main_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (main_notebook), 3), label42);
+
+  table8 = gtk_table_new (3, 3, FALSE);
+  gtk_widget_show (table8);
+  gtk_container_add (GTK_CONTAINER (main_notebook), table8);
+  gtk_container_set_border_width (GTK_CONTAINER (table8), 8);
+  gtk_table_set_row_spacings (GTK_TABLE (table8), 8);
+  gtk_table_set_col_spacings (GTK_TABLE (table8), 8);
+
+  label31 = gtk_label_new (&quot;PGM&quot;);
+  gtk_widget_show (label31);
+  gtk_table_attach (GTK_TABLE (table8), label31, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label31), 0, 0.5);
+
+  label32 = gtk_label_new (&quot;PPM&quot;);
+  gtk_widget_show (label32);
+  gtk_table_attach (GTK_TABLE (table8), label32, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label32), 0, 0.5);
+
+  pgm_save_as_button = gtk_button_new ();
+  gtk_widget_show (pgm_save_as_button);
+  gtk_table_attach (GTK_TABLE (table8), pgm_save_as_button, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_widget_set_sensitive (pgm_save_as_button, FALSE);
+
+  alignment4 = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_widget_show (alignment4);
+  gtk_container_add (GTK_CONTAINER (pgm_save_as_button), alignment4);
+
+  hbox3 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox3);
+  gtk_container_add (GTK_CONTAINER (alignment4), hbox3);
+
+  image1 = gtk_image_new_from_stock (&quot;gtk-save-as&quot;, GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox3), image1, FALSE, FALSE, 0);
+
+  label33 = gtk_label_new_with_mnemonic (&quot;Save As...&quot;);
+  gtk_widget_show (label33);
+  gtk_box_pack_start (GTK_BOX (hbox3), label33, FALSE, FALSE, 0);
+
+  ppm_save_as_button = gtk_button_new ();
+  gtk_widget_show (ppm_save_as_button);
+  gtk_table_attach (GTK_TABLE (table8), ppm_save_as_button, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_widget_set_sensitive (ppm_save_as_button, FALSE);
+
+  alignment5 = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_widget_show (alignment5);
+  gtk_container_add (GTK_CONTAINER (ppm_save_as_button), alignment5);
+
+  hbox4 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox4);
+  gtk_container_add (GTK_CONTAINER (alignment5), hbox4);
+
+  image2 = gtk_image_new_from_stock (&quot;gtk-save-as&quot;, GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image2);
+  gtk_box_pack_start (GTK_BOX (hbox4), image2, FALSE, FALSE, 0);
+
+  label34 = gtk_label_new_with_mnemonic (&quot;Save As...&quot;);
+  gtk_widget_show (label34);
+  gtk_box_pack_start (GTK_BOX (hbox4), label34, FALSE, FALSE, 0);
+
+  save_label = gtk_label_new (&quot;Export&quot;);
+  gtk_widget_show (save_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (main_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (main_notebook), 4), save_label);
+
+  vbox4 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox4);
+  gtk_container_add (GTK_CONTAINER (main_notebook), vbox4);
+
+  image3 = create_pixmap (hmgengui, &quot;hmgen.png&quot;);
+  gtk_widget_show (image3);
+  gtk_box_pack_start (GTK_BOX (vbox4), image3, FALSE, FALSE, 64);
+
+  about_message = gtk_label_new(&quot;\nVersion 0.9.0&quot;);
+  gtk_widget_show (about_message);
+  gtk_box_pack_start (GTK_BOX (vbox4), about_message, FALSE, FALSE, 0);
+  gtk_label_set_justify (GTK_LABEL (about_message), GTK_JUSTIFY_CENTER);
+
+  about_label = gtk_label_new (&quot;About...&quot;);
+  gtk_widget_show (about_label);
+  gtk_notebook_set_tab_label (GTK_NOTEBOOK (main_notebook), gtk_notebook_get_nth_page (GTK_NOTEBOOK (main_notebook), 5), about_label);
+
+  main_progressbar = gtk_progress_bar_new ();
+  gtk_widget_show (main_progressbar);
+  gtk_box_pack_start (GTK_BOX (vbox1), main_progressbar, FALSE, FALSE, 0);
+  gtk_progress_bar_set_text (GTK_PROGRESS_BAR (main_progressbar), &quot;Idle...&quot;);
+
+  g_signal_connect ((gpointer) hmgengui, &quot;delete_event&quot;,
+                    G_CALLBACK (gui_quit),
+                    NULL);
+  g_signal_connect ((gpointer) view_drawingarea, &quot;expose_event&quot;,
+                    G_CALLBACK (on_view_drawingarea_expose_event),
+                    NULL);
+  g_signal_connect ((gpointer) algorithm_combobox, &quot;changed&quot;,
+                    G_CALLBACK (on_algorithm_combobox_changed),
+                    NULL);
+  g_signal_connect ((gpointer) size_combobox, &quot;changed&quot;,
+                    G_CALLBACK (on_size_combobox_changed),
+                    NULL);
+  g_signal_connect ((gpointer) generate_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_generate_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) pgm_save_as_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_pgm_save_as_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) ppm_save_as_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_ppm_save_as_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) new_create_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_new_create_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) norm2_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_norm2_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) blur2_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_blur2_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) invert2_button, &quot;clicked&quot;,
+                    G_CALLBACK (on_invert2_button_clicked),
+                    NULL);
+  g_signal_connect ((gpointer) colormap_display, &quot;expose_event&quot;,
+                    G_CALLBACK (on_colormap_display_expose_event),
+                    NULL);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (hmgengui, hmgengui, &quot;hmgengui&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, main_notebook, &quot;main_notebook&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, view_scrolledwindow, &quot;view_scrolledwindow&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, view_drawingarea, &quot;view_drawingarea&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, view_label, &quot;view_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, algorithm_combobox, &quot;algorithm_combobox&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, size_combobox, &quot;size_combobox&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, generate_button, &quot;generate_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, postprocessing_notebook, &quot;postprocessing_notebook&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm_min_spinbutton, &quot;norm_min_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm_max_spinbutton, &quot;norm_max_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm_first_checkbutton, &quot;norm_first_checkbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm_last_checkbutton, &quot;norm_last_checkbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, normalize_label, &quot;normalize_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur_checkbutton, &quot;blur_checkbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur_sigma_spinbutton, &quot;blur_sigma_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur_yradius_spinbutton, &quot;blur_yradius_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur_xradius_spinbutton, &quot;blur_xradius_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur_label, &quot;blur_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, invert_checkbutton, &quot;invert_checkbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, invert_label, &quot;invert_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, algosettings_notebook, &quot;algosettings_notebook&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ff_seed_spinbutton, &quot;ff_seed_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ff_init_spinbutton, &quot;ff_init_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ff_nplates_spinbutton, &quot;ff_nplates_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ff_upfactor_spinbutton, &quot;ff_upfactor_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ff_downfactor_spinbutton, &quot;ff_downfactor_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ff_label, &quot;ff_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_roughness_spinbutton, &quot;mpd_roughness_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_displacement_spinbutton, &quot;mpd_displacement_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_br_spinbutton, &quot;mpd_br_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_bl_spinbutton, &quot;mpd_bl_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_tr_spinbutton, &quot;mpd_tr_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_tl_spinbutton, &quot;mpd_tl_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_seed_spinbutton, &quot;mpd_seed_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, mpd_label, &quot;mpd_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, forge_seed_spinbutton, &quot;forge_seed_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, forge_fracdim_spinbutton, &quot;forge_fracdim_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, forge_powscale_spinbutton, &quot;forge_powscale_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, forge_label, &quot;forge_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, generate_label, &quot;generate_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, pgm_save_as_button, &quot;pgm_save_as_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, ppm_save_as_button, &quot;ppm_save_as_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, save_label, &quot;save_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, about_message, &quot;about_message&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, about_label, &quot;about_label&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, main_progressbar, &quot;main_progressbar&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, view_sidepanel_notebook, &quot;view_sidepanel_note book&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, new_width_spinbutton, &quot;new_width_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, new_height_spinbutton, &quot;new_height_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, new_create_button, &quot;new_create_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, new_level_spinbutton, &quot;new_level_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm2_min_spinbutton, &quot;norm2_min_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm2_max_spinbutton, &quot;norm2_max_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, norm2_button, &quot;norm2_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur2_xrad_spinbutton, &quot;blur2_xrad_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur2_yrad_spinbutton, &quot;blur2_yrad_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur2_sigma_spinbutton, &quot;blur2_sigma_spinbutton&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, blur2_button, &quot;blur2_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, invert2_button, &quot;invert2_button&quot;);
+  GLADE_HOOKUP_OBJECT (hmgengui, colormap_display, &quot;colormap_display&quot;);
+
+  gtk_notebook_set_current_page(GTK_NOTEBOOK(main_notebook), 1);
+
+  return hmgengui;
+}
+

Added: trunk/gui_interface.h
===================================================================
--- trunk/gui_interface.h	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_interface.h	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,8 @@
+#ifndef HMG_GUI_INTERFACE_H
+#define HMG_GUI_INTERFACE_H
+
+#include &lt;gtk/gtk.h&gt;
+
+GtkWidget* create_hmgengui (void);
+
+#endif

Added: trunk/gui_main.c
===================================================================
--- trunk/gui_main.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_main.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,31 @@
+#include &lt;gtk/gtk.h&gt;
+#include &lt;locale.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;gui_interface.h&quot;
+#include &quot;gui_support.h&quot;
+#include &quot;lib_hmgen.c&quot;
+
+int main(int argc, char *argv[]) {
+    GtkWidget *hmgengui;
+
+    gtk_disable_setlocale();
+    setlocale(LC_ALL, &quot;C&quot;);
+
+    hmg_init_colormap();
+
+    g_thread_init(NULL);
+    gdk_threads_init();
+    gdk_threads_enter();
+
+    gtk_init(&amp;argc, &amp;argv);
+
+    add_pixmap_directory (&quot;.&quot;);
+
+    hmgengui = create_hmgengui();
+    gtk_widget_show(hmgengui);
+
+    gtk_main ();
+    gdk_threads_leave();
+
+    return 0;
+}

Added: trunk/gui_support.c
===================================================================
--- trunk/gui_support.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_support.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,97 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;gtk/gtk.h&gt;
+#include &quot;gui_support.h&quot;
+#include &quot;lib_hmgen.h&quot;
+
+GtkWidget *lookup_widget(GtkWidget *widget, const gchar *widget_name) {
+    GtkWidget *parent, *found_widget;
+
+    for(;;) {
+        if (GTK_IS_MENU (widget))
+            parent = gtk_menu_get_attach_widget (GTK_MENU (widget));
+        else
+            parent = widget-&gt;parent;
+        if (!parent)
+            parent = (GtkWidget*) g_object_get_data(G_OBJECT(widget),
+                                                            &quot;GladeParentKey&quot;);
+        if (parent == NULL)
+            break;
+        widget = parent;
+    }
+
+    found_widget = (GtkWidget*)g_object_get_data(G_OBJECT(widget),widget_name);
+    if (!found_widget)
+        g_warning (&quot;Widget not found: %s&quot;, widget_name);
+    return found_widget;
+}
+
+static GList *pixmaps_directories = NULL;
+
+void add_pixmap_directory(const gchar *directory) {
+    pixmaps_directories = g_list_prepend(pixmaps_directories,
+                                                        g_strdup(directory));
+}
+
+static gchar* find_pixmap_file(const gchar *filename) {
+    GList *elem;
+
+    elem = pixmaps_directories;
+    while (elem) {
+        gchar *pathname = g_strdup_printf (&quot;%s%s%s&quot;, (gchar*)elem-&gt;data,
+                                                 G_DIR_SEPARATOR_S, filename);
+        if (g_file_test(pathname, G_FILE_TEST_EXISTS))
+            return pathname;
+        g_free(pathname);
+        elem = elem-&gt;next;
+    }
+    return NULL;
+}
+
+GtkWidget* create_pixmap(GtkWidget *widget HMG_ATTR_UNUSED,
+                         const gchar *filename) {
+    gchar *pathname = NULL;
+    GtkWidget *pixmap;
+
+    if (!filename || !filename[0])
+        return gtk_image_new();
+
+    pathname = find_pixmap_file(filename);
+
+    if (!pathname) {
+        g_warning (&quot;Couldn't find pixmap file: %s&quot;, filename);
+        return gtk_image_new ();
+    }
+
+    pixmap = gtk_image_new_from_file(pathname);
+    g_free(pathname);
+    return pixmap;
+}
+
+GdkPixbuf* create_pixbuf(const gchar *filename) {
+    gchar *pathname = NULL;
+    GdkPixbuf *pixbuf;
+    GError *error = NULL;
+
+    if (!filename || !filename[0])
+        return NULL;
+
+    pathname = find_pixmap_file(filename);
+
+    if (!pathname) {
+        g_warning(&quot;Couldn't find pixmap file: %s&quot;, filename);
+        return NULL;
+    }
+
+    pixbuf = gdk_pixbuf_new_from_file(pathname, &amp;error);
+    if (!pixbuf) {
+      fprintf(stderr, &quot;Failed to load pixbuf file: %s: %s\n&quot;, pathname,
+                                                            error-&gt;message);
+      g_error_free(error);
+    }
+    g_free(pathname);
+    return pixbuf;
+}

Added: trunk/gui_support.h
===================================================================
--- trunk/gui_support.h	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/gui_support.h	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,12 @@
+#ifndef HMG_GUI_SUPPORT_H
+#define HMG_GUI_SUPPORT_H
+
+#include &lt;gtk/gtk.h&gt;
+
+GtkWidget* lookup_widget(GtkWidget *widget, const gchar *widget_name);
+void add_pixmap_directory(const gchar *directory);
+
+GtkWidget*  create_pixmap(GtkWidget *widget, const gchar *filename);
+GdkPixbuf*  create_pixbuf(const gchar *filename);
+
+#endif

Added: trunk/hmgen.png
===================================================================
(Binary files differ)


Property changes on: trunk/hmgen.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib_algo_ff.c
===================================================================
--- trunk/lib_algo_ff.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_algo_ff.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,103 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &quot;lib_hmgen.h&quot;
+
+#define HMGEN_MODULE &quot;Fault Formation&quot;
+
+static struct ff_settings_s {
+    unsigned int seed;
+    unsigned char init_value;
+    unsigned int number_of_plates;
+    unsigned int up_factor;
+    unsigned int down_factor;
+} ff_settings = { 42, 128, 512, 1, 1 };
+
+static const hmg_param_t params_ff[] = {
+    { &quot;seed=&quot;, &amp;ff_settings.seed, 0.0, 4294967295.0, PARAM_INT },
+    { &quot;init=&quot;, &amp;ff_settings.init_value, 0.0, 255.0, PARAM_CHAR },
+    { &quot;n=&quot;, &amp;ff_settings.number_of_plates, 0.0, 4294967295.0, PARAM_INT },
+    { &quot;up=&quot;, &amp;ff_settings.up_factor, 0.0, 255.0, PARAM_INT },
+    { &quot;down=&quot;, &amp;ff_settings.down_factor, 0.0, 255.0, PARAM_INT },
+    { NULL, NULL, 0, 0, 0 }
+};
+
+static void algo_ff(unsigned char *map, unsigned char *tempmap HMG_ATTR_UNUSED,
+                    unsigned int w, unsigned int h) {
+    unsigned int x, y, a = 0, b = 0, c = 0, d = 0, side, i;
+    int t;
+    float r;
+
+    srand(ff_settings.seed);
+
+    for (x=0; x&lt;w; x++)
+        for (y=0; y&lt;h; y++)
+            map[x+y*w] = ff_settings.init_value;
+
+    for (i=0; i&lt;ff_settings.number_of_plates; i++) {
+        progress_meter((int)round(i*100.0/(ff_settings.number_of_plates-1)));
+        switch (rand()&amp;3) {
+        case 0:
+            a = 0;
+            b = rand() % h;
+            break;
+        case 1:
+            a = rand() % w;
+            b = 0;
+            break;
+        case 2:
+            a = w-1;
+            b = rand() % h;
+            break;
+        case 3:
+            a = rand() % w;
+            b = h-1;
+            break;
+        }
+        do {
+            switch (rand()&amp;3) {
+            case 0:
+                c = 0;
+                d = rand() % h;
+                break;
+            case 1:
+                c = rand() % w;
+                d = 0;
+                break;
+            case 2:
+                c = w-1;
+                d = rand() % h;
+                break;
+            case 3:
+                c = rand() % w;
+                d = h-1;
+                break;
+            }
+        } while (a == c || b == d);
+
+        side = rand()&amp;1;
+
+        for (x=0; x&lt;w; x++) {
+            for (y=0; y&lt;h; y++) {
+                r = (float) y - b - (((float)d-b)/((float)c-a)) * ((float)x - (float)a);
+                r *= side ? -1 : 1;
+                if (r&gt;0) {
+                    t = (int)map[x+y*w] + ff_settings.up_factor;
+                    map[x+y*w] = t&gt;255 ? 255 : t;
+                } else {
+                    t = (int)map[x+y*w] - ff_settings.down_factor;
+                    map[x+y*w] = t&lt;0 ? 0 : t;
+                }
+            }
+        }
+    }
+    progress_meter(-1);
+}
+
+const hmg_algorithm_t hmg_algo_ff_info = {
+    &quot;Fault Formation&quot;,
+    algo_ff,
+    params_ff
+};
+

Added: trunk/lib_algo_forge.c
===================================================================
--- trunk/lib_algo_forge.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_algo_forge.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,293 @@
+/* This code is mostly taken from ppmforge.c
+ * Author: John Walker <A HREF="http://www.fourmilab.ch/">http://www.fourmilab.ch/</A> (C)1989
+ *
+ * Permission  to  use, copy, modify, and distribute this software and
+ * its documentation  for  any  purpose  and  without  fee  is  hereby
+ * granted,  without any conditions or restrictions.  This software is
+ * provided &quot;as is&quot; without express or implied warranty.
+ *
+ * Modifications and adaptation by Ivo van Poorten (C)2007
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#define _XOPEN_SOURCE
+#define __USE_XOPEN
+#include &lt;math.h&gt;
+#include &lt;assert.h&gt;
+#include &quot;lib_hmgen.h&quot;
+
+#define HMGEN_MODULE &quot;Forge&quot;
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#define hugeVal HUGE_VAL
+
+#define MIN(a,b)    (a&lt;b?a:b)
+#define MAX(a,b)    (a&gt;b?a:b)
+
+extern double arand;
+
+static struct forge_settings_s {
+    unsigned int seed;
+    double fracdim;
+    double powscale;
+} forge_settings = { 47, 2.4, 1.2 };
+
+static const hmg_param_t params_forge[] = {
+    { &quot;seed=&quot;, &amp;forge_settings.seed, 0.0, 4294967295.0, PARAM_INT },
+    { &quot;fracdim=&quot;, &amp;forge_settings.fracdim, 0.0, 3.0, PARAM_DOUBLE },
+    { &quot;powscale=&quot;, &amp;forge_settings.powscale, 0.0, 8.0, PARAM_DOUBLE },
+    { NULL, NULL, 0, 0, 0 }
+};
+
+static int meshsize;
+
+#define Real(v, x, y)  v[1 + (((x) * meshsize) + (y)) * 2]
+#define Imag(v, x, y)  v[2 + (((x) * meshsize) + (y)) * 2]
+
+/* FOURN  --  Multi-dimensional fast Fourier transform
+ *
+ * data     A one-dimensional array of floats (NOTE!!! NOT DOUBLES!!)
+ *          indexed from one (NOTE!!! NOT ZERO!!), containing  pairs of
+ *          numbers representing the complex valued samples. The Fourier
+ *          transformed results  are returned in the same array.
+ *
+ * nn       An  array specifying the edge size in each dimension. THIS ARRAY
+ *          IS INDEXED FROM ONE, AND ALL THE EDGE SIZES MUST BE POWERS OF TWO!!
+ *
+ * ndim     Number of dimensions of FFT to perform. Set to 2 for 2D FFT.
+ *
+ * isign    If 1, a Fourier transform is done; if -1 the  inverse
+ *          transformation is performed.
+ *
+ * This  function  is essentially as given in Press et al., &quot;Numerical
+ * Recipes In C&quot;, Section 12.11, pp.  467-470.
+ */
+
+static void fourn(data, nn, ndim, isign)
+    float data[];
+    int nn[], ndim, isign;
+{
+    register int i1, i2, i3;
+    int i2rev, i3rev, ip1, ip2, ip3, ifp1, ifp2;
+    int ibit, idim, k1, k2, n, nprev, nrem, ntot;
+    float tempi, tempr;
+    double theta, wi, wpi, wpr, wr, wtemp;
+
+#define SWAP(a,b) tempr=(a); (a) = (b); (b) = tempr
+
+    ntot = 1;
+    for (idim = 1; idim &lt;= ndim; idim++)
+        ntot *= nn[idim];
+    nprev = 1;
+    for (idim = ndim; idim &gt;= 1; idim--) {
+        /* FIXME: this makes only two steps */
+        progress_meter(66+(int)round((ndim-idim)*34.0/ndim));
+
+        n = nn[idim];
+        nrem = ntot / (n * nprev);
+        ip1 = nprev &lt;&lt; 1;
+        ip2 = ip1 * n;
+        ip3 = ip2 * nrem;
+        i2rev = 1;
+        for (i2 = 1; i2 &lt;= ip2; i2 += ip1) {
+            if (i2 &lt; i2rev) {
+                for (i1 = i2; i1 &lt;= i2 + ip1 - 2; i1 += 2) {
+                    for (i3 = i1; i3 &lt;= ip3; i3 += ip2) {
+                        i3rev = i2rev + i3 - i2;
+                        SWAP(data[i3], data[i3rev]);
+                        SWAP(data[i3 + 1], data[i3rev + 1]);
+                    }
+                }
+            }
+            ibit = ip2 &gt;&gt; 1;
+            while (ibit &gt;= ip1 &amp;&amp; i2rev &gt; ibit) {
+                i2rev -= ibit;
+                ibit &gt;&gt;= 1;
+            }
+            i2rev += ibit;
+        }
+        ifp1 = ip1;
+        while (ifp1 &lt; ip2) {
+            ifp2 = ifp1 &lt;&lt; 1;
+            theta = isign * (M_PI * 2) / (ifp2 / ip1);
+            wtemp = sin(0.5 * theta);
+            wpr = -2.0 * wtemp * wtemp;
+            wpi = sin(theta);
+            wr = 1.0;
+            wi = 0.0;
+            for (i3 = 1; i3 &lt;= ifp1; i3 += ip1) {
+                for (i1 = i3; i1 &lt;= i3 + ip1 - 2; i1 += 2) {
+                    for (i2 = i1; i2 &lt;= ip3; i2 += ifp2) {
+                        k1 = i2;
+                        k2 = k1 + ifp1;
+                        tempr = wr * data[k2] - wi * data[k2 + 1];
+                        tempi = wr * data[k2 + 1] + wi * data[k2];
+                        data[k2] = data[k1] - tempr;
+                        data[k2 + 1] = data[k1 + 1] - tempi;
+                        data[k1] += tempr;
+                        data[k1 + 1] += tempi;
+                    }
+                }
+                wr = (wtemp = wr) * wpr - wi * wpi + wr;
+                wi = wi * wpr + wtemp * wpi + wi;
+            }
+            ifp1 = ifp2;
+        }
+        nprev *= n;
+    }
+}
+#undef SWAP
+
+/* SPECTRALSYNTH  --  Spectrally synthesized fractal motion in two
+ * dimensions. This algorithm is given under the name SpectralSynthesisFM2D
+ * on page 108 of Peitgen &amp; Saupe.
+ */
+
+static void spectral_synth(float **x, int n, double h) {
+    unsigned int bl;
+    int i, j, i0, j0, nsize[3];
+    double rad, phase, rcos, rsin;
+    float *a;
+
+    bl = ((((unsigned long) n) * n) + 1) * 2 * sizeof(float);
+    a = (float *) calloc(bl, 1);
+    if (a == (float *) 0) {
+        fprintf(stderr, &quot;error, cannot allocate memory\n&quot;);
+        exit(1);
+    }
+    *x = a;
+
+    for (i = 0; i &lt;= n / 2; i++) {
+        progress_meter((int)round(i*33.0/((n/2)-1)));
+        for (j = 0; j &lt;= n / 2; j++) {
+            phase = 2 * M_PI * ((rand() &amp; 0x7FFF) / arand);
+            if (i != 0 || j != 0) {
+                rad = pow((double)(i*i + j*j), -(h + 1) / 2) * hmg_rng_gauss();
+            } else {
+                rad = 0;
+            }
+            rcos = rad * cos(phase);
+            rsin = rad * sin(phase);
+            Real(a, i, j) = rcos;
+            Imag(a, i, j) = rsin;
+            i0 = (i == 0) ? 0 : n - i;
+            j0 = (j == 0) ? 0 : n - j;
+            Real(a, i0, j0) = rcos;
+            Imag(a, i0, j0) = - rsin;
+        }
+    }
+    Imag(a, n / 2, 0) = 0;
+    Imag(a, 0, n / 2) = 0;
+    Imag(a, n / 2, n / 2) = 0;
+    for (i = 1; i &lt;= n / 2 - 1; i++) {
+        progress_meter(33 + (int)round(i*33.0/((n/2)-1)));
+        for (j = 1; j &lt;= n / 2 - 1; j++) {
+            phase = 2 * M_PI * ((rand() &amp; 0x7FFF) / arand);
+            rad = pow((double)(i*i + j*j), -(h + 1) / 2) * hmg_rng_gauss();
+            rcos = rad * cos(phase);
+            rsin = rad * sin(phase);
+            Real(a, i, n - j) = rcos;
+            Imag(a, i, n - j) = rsin;
+            Real(a, n - i, j) = rcos;
+            Imag(a, n - i, j) = - rsin;
+        }
+    }
+
+    nsize[0] = 0;
+    nsize[1] = nsize[2] = n;          /* Dimension of frequency domain array */
+    fourn(a, nsize, 2, -1);       /* Take inverse 2D Fourier transform */
+}
+
+static void power_law_scaling(float * const a, int const meshsize,
+                              double const powscale) {
+
+    if (powscale != 1.0) {
+        int i, j;
+        for (i = 0; i &lt; meshsize; i++) {
+            for (j = 0; j &lt; meshsize; j++) {
+                double const r = Real(a, i, j);
+                if (r &gt; 0)
+                    Real(a, i, j) = pow(r, powscale);
+            }
+        }
+    }
+}
+
+static void compute_extreme_real(const float * const a, int const meshsize,
+                                 double * const rminP, double * const rmaxP) {
+    double rmin, rmax;
+    int i, j;
+
+    rmin = hugeVal;
+    rmax = -hugeVal;
+
+    for (i = 0; i &lt; meshsize; i++) {
+        for (j = 0; j &lt; meshsize; j++) {
+            double r = Real(a, i, j);
+
+            rmin = MIN(rmin, r);
+            rmax = MAX(rmax, r);
+        }
+    }
+    *rminP = rmin;
+    *rmaxP = rmax;
+}
+
+/* Replace the real part of each element of the 'a' array with a
+ * measure of how far the real is from the middle; sort of a standard
+ * deviation.
+ */
+static void replace_with_spread(float * const a, int const meshsize) {
+    double rmin, rmax;
+    double rmean, rrange;
+    int i, j;
+
+    compute_extreme_real(a, meshsize, &amp;rmin, &amp;rmax);
+
+    rmean = (rmin + rmax) / 2;
+    rrange = (rmax - rmin) / 2;
+
+    for (i = 0; i &lt; meshsize; i++) {
+        for (j = 0; j &lt; meshsize; j++) {
+            Real(a, i, j) = (Real(a, i, j) - rmean) / rrange;
+        }
+    }
+}
+
+static void algo_forge(unsigned char *map,
+                       unsigned char *tempmap HMG_ATTR_UNUSED,
+                       unsigned int w, unsigned int h) {
+    float *a;
+    unsigned int x, y;
+
+    hmg_rng_initgauss(forge_settings.seed);
+
+    assert(w == h);
+    meshsize = w-1;
+
+    spectral_synth(&amp;a, meshsize, 3.0 - forge_settings.fracdim);
+    assert(a);
+
+    power_law_scaling(a, meshsize, forge_settings.powscale);
+    replace_with_spread(a, meshsize);
+
+    for (y=0; y&lt;h-1; y++)
+        for(x=0; x&lt;w-1; x++)
+            map[x+y*w] = round ((Real(a,x,y) + 1.0) * 127.5);
+
+    if (a) free(a);
+    progress_meter(100);
+    progress_meter(-1);
+}
+
+const hmg_algorithm_t hmg_algo_forge_info = {
+    &quot;ppmforge/gforge - noise/fft&quot;,
+    algo_forge,
+    params_forge
+};
+

Added: trunk/lib_algo_mpd.c
===================================================================
--- trunk/lib_algo_mpd.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_algo_mpd.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,136 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &quot;lib_hmgen.h&quot;
+
+#define HMGEN_MODULE &quot;Midpoint Displacement&quot;
+
+static struct mpd_settings_s {
+    unsigned int seed;
+    unsigned char tl, tr, bl, br;   /* top-left --&gt; bottom-right */
+    unsigned char d;                /* displacement */
+    double r;                       /* roughness factor */
+} mpd_settings = { 42, 128, 128, 128, 128, 16, 0.6f };
+
+static const hmg_param_t params_mpd[] = {
+    { &quot;seed=&quot;, &amp;mpd_settings.seed, 0.0, 4294967295.0, PARAM_INT },
+    { &quot;tl=&quot;,   &amp;mpd_settings.tl, 0.0, 255.0, PARAM_CHAR },
+    { &quot;tr=&quot;,   &amp;mpd_settings.tr, 0.0, 255.0, PARAM_CHAR },
+    { &quot;bl=&quot;,   &amp;mpd_settings.bl, 0.0, 255.0, PARAM_CHAR },
+    { &quot;br=&quot;,   &amp;mpd_settings.br, 0.0, 255.0, PARAM_CHAR },
+    { &quot;d=&quot;,    &amp;mpd_settings.d,  0.0, 255.0, PARAM_CHAR },
+    { &quot;r=&quot;,    &amp;mpd_settings.r,  0.0, 2.0,  PARAM_DOUBLE },
+    { NULL, NULL, 0, 0, 0 }
+};
+
+static inline unsigned char getpix(unsigned char *map,
+                                   int w, int h, int x, int y) {
+    if (x&lt;0) x += w-1;
+    else if (x&gt;=w) x -= w-1;
+    if (y&lt;0) y += h-1;
+    else if (y&gt;=h) y -= h-1;
+    return map[x+y*w];
+}
+
+static inline void putpix(unsigned char *map,
+                          int w, int h, int x, int y, int c) {
+    if (x&lt;0) x += w-1;
+    else if (x&gt;=w) x -= w-1;
+    if (y&lt;0) y += h-1;
+    else if (y&gt;=h) y -= h-1;
+    if (c&lt;0) c=0;
+    else if (c&gt;255) c=255;
+    map[x+y*w] = c;
+}
+
+static inline char myrand(unsigned int d) {
+    return rand() % (2*d) - d;
+}
+
+static void mpd(unsigned char *map, int x, int y,
+                unsigned int xw, unsigned int yh,
+                unsigned int w, unsigned int h,
+                unsigned char d, unsigned int m) {
+    int tl = getpix(map, w, h, x, y),
+        tr = getpix(map, w, h, x+xw, y),
+        bl = getpix(map, w, h, x, y+yh),
+        br = getpix(map, w, h, x+xw, y+yh),
+        midu, midd, midl, midr, mid;
+
+    xw /= 2;
+    yh /= 2;
+
+    if (m) {
+        mid = round((tl+tr+bl+br)/4.0 + myrand(d));
+        putpix(map, w, h, x+xw, y+yh, mid);
+
+        return;
+    }
+
+    mid  = getpix(map, w, h, x+xw, y+yh);
+    midu = getpix(map, w, h, x+xw, y-yh);
+    midd = getpix(map, w, h, x+xw, y+yh+yh+yh);
+    midl = getpix(map, w, h, x-xw, y+yh);
+    midr = getpix(map, w, h, x+xw+xw+xw, y+yh);
+
+    putpix(map, w, h, x+xw,    y,       round((tl+tr+mid+midu)/4.0 +myrand(d)));
+    putpix(map, w, h, x,       y+yh,    round((tl+bl+mid+midl)/4.0 +myrand(d)));
+    putpix(map, w, h, x+xw+xw, y+yh,    round((tr+br+mid+midr)/4.0 +myrand(d)));
+    putpix(map, w, h, x+xw,    y+yh+yh, round((bl+br+mid+midd)/4.0 +myrand(d)));
+}
+
+static void algo_mpd(unsigned char *map,
+                     unsigned char *tempmap HMG_ATTR_UNUSED,
+                     unsigned int w, unsigned int h) {
+    unsigned int s = w-1, t = h-1, x, y, cnt = 0, tot = 0;
+    double dd = mpd_settings.d;
+    unsigned char d;
+
+    /* calculate total number of calls to mpd() for progress counter */
+    y = s/2;
+    while (y!=1) {
+        tot += y*y;
+        y /= 2;
+    }
+    tot++;
+    tot *= 2;
+
+    srand(mpd_settings.seed);
+
+    map[0]       = mpd_settings.tl;
+    map[w-1]     = mpd_settings.tr;
+    map[(h-1)*w] = mpd_settings.bl;
+    map[h*w-1]   = mpd_settings.br;
+
+    while (s != 1) {
+        d = round(dd);
+        d = d&lt;1 ? 1 : d;
+        for (y=0; y&lt;h-1; y+=t) {
+            progress_meter((int)round(cnt*100.0/tot));
+            for (x=0; x&lt;w-1; x+=s) {
+                mpd(map, x, y, s, t, w, h, d, 1);
+                cnt++;
+            }
+        }
+        for (y=0; y&lt;h-1; y+=t) {
+            progress_meter((int)round(cnt*100.0/tot));
+            for (x=0; x&lt;w-1; x+=s) {
+                mpd(map, x, y, s, t, w, h, d, 0);
+                cnt++;
+            }
+        }
+        progress_meter((int)round(cnt*100.0/tot));
+        s /= 2;
+        t /= 2;
+        dd *= mpd_settings.r;
+    }
+    progress_meter(-1);
+}
+
+const hmg_algorithm_t hmg_algo_mpd_info = {
+    &quot;Midpoint Displacement&quot;,
+    algo_mpd,
+    params_mpd
+};
+

Added: trunk/lib_hmgen.c
===================================================================
--- trunk/lib_hmgen.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_hmgen.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,104 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &quot;lib_hmgen.h&quot;
+
+extern const hmg_algorithm_t hmg_algo_ff_info;
+extern const hmg_algorithm_t hmg_algo_mpd_info;
+extern const hmg_algorithm_t hmg_algo_forge_info;
+
+const hmg_algorithm_t *hmg_algorithms[] = {
+    &amp;hmg_algo_ff_info,
+    &amp;hmg_algo_mpd_info,
+    &amp;hmg_algo_forge_info
+};
+
+static void default_progress_meter(char *context, int p) {
+    if (p&lt;0)
+        fprintf(stderr, &quot;\r[done] %s\n&quot;, context);
+    else
+        fprintf(stderr, &quot;\r[%3i%%] %s\r&quot;, p, context);
+}
+
+void (*hmg_progress_meter)(char *context, int p) = default_progress_meter;
+
+int hmg_parse_params(const char *arg, const hmg_param_t *params) {
+    unsigned int n, i;
+    const char *p = arg, *t;
+
+    for (n=0; params[n].name; n++)  ;
+
+    while (p!=NULL &amp;&amp; *p!='\0') {
+        for (i=0; i&lt;n; i++)
+            if (!strncmp(p, params[i].name, strlen(params[i].name)))
+                break;
+
+        if (i == n) {
+            fprintf(stderr, &quot;unknown parameter: %8s...\n&quot;, p);
+            return 0;
+        }
+
+        p = strchr(p, '=');
+        assert(*p == '=');
+        p++;
+
+        switch (params[i].type) {
+        case PARAM_INT: {
+            int x;
+
+            x = atoi(p);
+            if (x&lt;params[i].min) {
+                fprintf(stderr, &quot;%s, value smaller than %i\n&quot;, params[i].name,
+                                                        (int) params[i].min);
+                return 0;
+            } else if (x&gt;params[i].max) {
+                fprintf(stderr, &quot;%s, value larger than %i\n&quot;, params[i].name,
+                                                        (int) params[i].max);
+                return 0;
+            }
+            *(int*)params[i].store = x;
+            break; }
+        case PARAM_CHAR: {
+            int x;
+
+            x = atoi(p);
+            if (x&lt;params[i].min) {
+                fprintf(stderr, &quot;%s, value smaller than %i\n&quot;, params[i].name,
+                                                        (int) params[i].min);
+                return 0;
+            } else if (x&gt;params[i].max) {
+                fprintf(stderr, &quot;%s, value larger than %i\n&quot;, params[i].name,
+                                                        (int) params[i].max);
+                return 0;
+            }
+            *(char*)params[i].store = x;
+            break; }
+        case PARAM_DOUBLE: {
+            double d;
+
+            d = atof(p);
+            if (d&lt;params[i].min) {
+                fprintf(stderr, &quot;%s, value smaller than %0.2f\n&quot;,
+                                                params[i].name, params[i].min);
+                return 0;
+            } else if (d&gt;params[i].max) {
+                fprintf(stderr, &quot;%s, value larger than %0.2f\n&quot;,
+                                                params[i].name, params[i].max);
+                return 0;
+            }
+            *(double*)params[i].store = d;
+            break; }
+        default:
+            assert(0);
+            break;
+        }
+
+        t = strchr(p, ':');
+        if (t == NULL)
+            break;
+        p = t+1;
+    }
+
+    return 1;
+}

Added: trunk/lib_hmgen.h
===================================================================
--- trunk/lib_hmgen.h	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_hmgen.h	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,62 @@
+#ifndef HMG_LIB_HMGEN_H
+#define HMG_LIB_HMGEN_H
+
+extern void (*hmg_progress_meter)(char *context, int p);
+
+typedef enum hmg_param_type_e {
+    PARAM_INT,
+    PARAM_CHAR,
+    PARAM_DOUBLE
+} hmg_param_type_t;
+
+typedef struct hmg_param_s {
+    char *name;
+    void *store;
+    double min, max;
+    hmg_param_type_t type;
+} hmg_param_t;
+
+typedef struct hmg_algorithm_s {
+    const char *name;
+    void (*func)(unsigned char *map, unsigned char *tempmap,
+                 unsigned int width, unsigned int height);
+    const hmg_param_t *params;
+} hmg_algorithm_t;
+
+extern const hmg_algorithm_t *hmg_algorithms[];
+
+int hmg_parse_params(const char *arg, const hmg_param_t *params);
+
+void hmg_normalize(unsigned char *map,
+                   unsigned int normmin, unsigned int normmax,
+                   unsigned int w, unsigned int h);
+
+void hmg_gaussian_blur(unsigned char *map, unsigned char *tempmap,
+                       int blurx, int blury, double blursigma,
+                       unsigned int w, unsigned int h);
+
+void hmg_invert(unsigned char *map, unsigned int w, unsigned int h);
+
+extern unsigned char hmg_colormap[256][3];
+
+void hmg_init_colormap(void);
+
+void hmg_rng_initgauss(unsigned int seed);
+double hmg_rng_gauss(void);
+
+#ifdef __GNUC__
+#define HMG_ATTR_UNUSED     __attribute__((unused))
+#else
+#define HMG_ATTR_UNUSED
+#endif
+
+#define ALGO_FF     0       /* Fault Formation */
+#define ALGO_MDP    1       /* Midpoint Displacement */
+#define ALGO_FORGE  2       /* ppmforge/gforge */
+#define ALGO_LAST   3       /* Nothing */
+
+/* Handy shortcut */
+
+#define progress_meter(a) hmg_progress_meter(HMGEN_MODULE, a)
+
+#endif

Added: trunk/lib_postproc.c
===================================================================
--- trunk/lib_postproc.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_postproc.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,109 @@
+#include &lt;stdio.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &quot;lib_hmgen.h&quot;
+
+#define HMGEN_MODULE &quot;Normalize&quot;
+
+void hmg_normalize(unsigned char *map,
+                   unsigned int normmin, unsigned int normmax,
+                   unsigned int w, unsigned int h) {
+    unsigned int x = 0, y, minval = 255, maxval = 0, v = 0;
+    double f;
+
+    for (y=0; y&lt;h; y++) {
+        progress_meter((int)round(y*50.0/(h-1)));
+        for (x=0; x&lt;w; x++) {
+            v = map[x+y*w];
+            minval = v&lt;minval ? v : minval;
+            maxval = v&gt;maxval ? v : maxval;
+        }
+    }
+
+    f = 1.0 * (normmax-normmin) / (maxval-minval);
+
+    for (y=0; y&lt;h; y++) {
+        progress_meter(50 + (int)round(y*50.0/(h-1)));
+        for (x=0; x&lt;w; x++) {
+            v = map[x+y*w];
+            map[x+y*w] = round((v - minval) * f + normmin);
+        }
+    }
+    progress_meter(-1);
+}
+
+#undef  HMGEN_MODULE
+#define HMGEN_MODULE &quot;Gaussian Blur&quot;
+
+void hmg_gaussian_blur(unsigned char *map, unsigned char *tempmap,
+                       int blurx, int blury,
+                       double blursigma,
+                       unsigned int w, unsigned int h) {
+    double mask[blurx*blury];
+    double cx = 0, cy = 0, r = 0, m = 0, nv;
+    int x, y, a, b, v;
+    double cr = -1.0/(2.0*blursigma*blursigma);
+
+    memcpy(tempmap, map, w*h);
+
+    for (y=0; y&lt;blury; y++) {
+        for (x=0; x&lt;blurx; x++) {
+            cx = (double) x - (double)(blurx-1) / 2.0;
+            cy = (double) y - (double)(blury-1) / 2.0;
+            r = cx*cx + cy*cy;
+            m += exp(cr*r);
+        }
+    }
+    m = 1.0/m;
+
+    for (y=0; y&lt;blury; y++) {
+        for (x=0; x&lt;blurx; x++) {
+            cx = (double) x - (double)(blurx-1) / 2.0;
+            cy = (double) y - (double)(blury-1) / 2.0;
+            r = cx*cx + cy*cy;
+            mask[y*blurx+x] = m * exp(cr*r);
+        }
+    }
+
+    for (y=0; y&lt;(int)h; y++) {
+        progress_meter((int)round(y*100.0/(h-1)));
+        for (x=0; x&lt;(int)w; x++) {
+
+            nv = 0.0;
+
+            for (b=0; b&lt;blury; b++) {
+                int bb = y+b-blury/2;
+                bb = bb&gt;=(int)h ? h-1 : bb&lt;0 ? 0 : bb;
+
+                for (a=0; a&lt;blurx; a++) {
+                    int aa = x+a-blurx/2;
+                    aa = aa&gt;=(int)w ? w-1 : aa&lt;0 ? 0 : aa;
+
+                    v = tempmap[aa+bb*w];
+                    nv += v * mask[a+b*blurx];
+                }
+            }
+
+            nv = round(nv);
+            nv = nv&gt;255 ? 255 : nv&lt;0 ? 0 : nv;
+            map[x+y*w] = nv;
+        }
+    }
+    progress_meter(-1);
+}
+
+
+#undef  HMGEN_MODULE
+#define HMGEN_MODULE &quot;Invert&quot;
+
+void hmg_invert(unsigned char *map, unsigned int w, unsigned int h) {
+    unsigned int x = 0, y;
+
+    for (y=0; y&lt;h; y++) {
+        progress_meter((int)round(y*100.0/(h-1)));
+        for (x=0; x&lt;w; x++)
+            map[x+y*w] = 255 - map[x+y*w];
+    }
+    progress_meter(-1);
+}

Added: trunk/lib_util.c
===================================================================
--- trunk/lib_util.c	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/lib_util.c	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,74 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+unsigned char hmg_colormap[256][3];
+
+#define B_WATER_GRASS    32
+#define B_GRASS_ROCK     96
+#define B_ROCK_SNOW      192
+
+#if 0
+static unsigned char waterstart[3] = {   0,   0, 128 },
+                     waterend[3]   = {   0,   0, 255 },
+                     grassstart[3] = {   0, 128,   0 },
+                     grassend[3]   = {   0, 255,   0 },
+                     rockstart[3]  = { 128,   0,   0 },
+                     rockend[3]    = { 255, 128, 128 },
+                     snowstart[3]  = { 128, 128, 128 },
+                     snowend[3]    = { 255, 255, 255 };
+#endif
+static unsigned char waterstart[3] = {   0,   0, 96 },
+                     waterend[3]   = {   0,   0, 192 },
+                     grassstart[3] = {   0, 0,  192 },
+                     grassend[3]   = {   0, 192,   0 },
+                     rockstart[3]  = { 0,   192,   0 },
+                     rockend[3]    = { 192, 128, 128 },
+                     snowstart[3]  = { 192, 128, 128 },
+                     snowend[3]    = { 255, 255, 255 };
+
+// colormap[last] is NOT set
+static void do_gradient(unsigned char start[3], unsigned char end[3],
+                        int first, int last) {
+    double d[3];
+    int steps = last - first - 1, i;
+
+    d[0] = (double)(end[0] - start[0]) / steps;
+    d[1] = (double)(end[1] - start[1]) / steps;
+    d[2] = (double)(end[2] - start[2]) / steps;
+
+    for (i=first; i&lt;last; i++) {
+        int j = i-first;
+        hmg_colormap[i][0] = round((double)start[0] + d[0]*j);
+        hmg_colormap[i][1] = round((double)start[1] + d[1]*j);
+        hmg_colormap[i][2] = round((double)start[2] + d[2]*j);
+    }
+}
+
+void hmg_init_colormap(void) {
+    do_gradient(waterstart, waterend, 0,             B_WATER_GRASS);
+    do_gradient(grassstart, grassend, B_WATER_GRASS, B_GRASS_ROCK);
+    do_gradient(rockstart,  rockend,  B_GRASS_ROCK,  B_ROCK_SNOW);
+    do_gradient(snowstart,  snowend,  B_ROCK_SNOW,   256);
+}
+
+#define nrand 4
+
+double arand;
+static double gaussadd, gaussfac;
+
+void hmg_rng_initgauss(unsigned int seed) {
+    arand = pow(2.0, 15.0) - 1.0;
+    gaussadd = sqrt(3.0 * nrand);
+    gaussfac = 2 * gaussadd / (nrand * nrand);
+    srand(seed);
+}
+
+double hmg_rng_gauss(void) {
+    int i;
+    double sum = 0.0;
+
+    for (i=1; i&lt;=nrand; i++)
+        sum += rand() &amp; 0x7fff;
+    return gaussfac * sum - gaussadd;
+}

Added: trunk/target.mak
===================================================================
--- trunk/target.mak	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/target.mak	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,43 @@
+TARGET ?= linux-gcc
+
+ifeq ($(TARGET),linux-gcc)
+CC = gcc
+CC_DEP = $(CC)
+AR ?= ar
+RANLIB ?= ranlib
+STRIP ?= strip
+PKG_CONFIG ?= pkg-config
+STD_FLAGS=-std=c99
+WARN_FLAGS=-Wall -W
+OPT_FLAGS=-O3
+DEBUG_FLAGS=-g
+DEF_CFLAGS = $(STD_FLAGS) $(WARN_FLAGS) $(OPT_FLAGS) $(DEBUG_FLAGS)
+DEF_LDFLAGS = -lm $(DEBUG_FLAGS)
+GTK_CFLAGS = `$(PKG_CONFIG) --cflags gtk+-2.0 gthread-2.0`
+GTK_LDFLAGS = `$(PKG_CONFIG) --static --libs gtk+-2.0 gthread-2.0`
+DEP_FLAGS = -MM
+AR_FLAGS = cru
+EXESUF =
+OBJSUF = .o
+endif
+
+ifeq ($(TARGET),linux-suncc)
+CC = suncc
+CC_DEP = $(CC)
+AR ?= ar
+RANLIB ?= ranlib
+STRIP ?= strip
+PKG_CONFIG ?= pkg-config
+STD_FLAGS=-Xc
+WARN_FLAGS=
+OPT_FLAGS=-xO5
+DEBUG_FLAGS=-g
+DEF_CFLAGS = $(STD_FLAGS) $(WARN_FLAGS) $(OPT_FLAGS) $(DEBUG_FLAGS)
+DEF_LDFLAGS = -lm $(DEBUG_FLAGS)
+GTK_CFLAGS = `$(PKG_CONFIG) --cflags gtk+-2.0 gthread-2.0 | sed 's/-pthread//'`
+GTK_LDFLAGS = `$(PKG_CONFIG) --static --libs gtk+-2.0 gthread-2.0 | sed 's/-pthread//'`
+DEP_FLAGS = -xM
+AR_FLAGS = cru
+EXESUF =
+OBJSUF = .o
+endif

Added: trunk/version.h
===================================================================
--- trunk/version.h	2007-08-26 17:08:51 UTC (rev 0)
+++ trunk/version.h	2007-08-28 10:38:44 UTC (rev 1)
@@ -0,0 +1,11 @@
+#ifndef VERSION_H
+#define VERSION_H
+
+#define VERSION_MAJOR       0
+#define VERSION_MINOR       9
+#define VERSION_MICRO       0
+#define VERSION_INT         (VERSION_MAJOR&lt;&lt;8)+(VERSION_MINOR&lt;&lt;4)+VERSION_MICRO
+#define VERSION_STRING      &quot;0.9.0&quot;
+#define COPYRIGHT_STRING    &quot;Copyright (C) 2007&quot;
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000001.html">[Hmgen-svnlog] r2 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/hmgen-svnlog">More information about the Hmgen-svnlog
mailing list</a><br>
</body></html>
